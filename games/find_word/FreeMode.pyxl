FreeMode
════════════════════════════════════════════════════════════════════════
let selection_color = TILE_CENTER_SELECTED_COLOR


def player_update_back_button(player, board_pos):
    if size(player.free_row):
        player_update_aux_button(player, board_pos, remove_last_tile, shapes.arrow.x_flipped, "b", ∅, true)



/* Recompute `player.history.free` from `player.free_row` and return the `free_selection_color`.
   See also `player_selection_change_callback()` for the `Play` mode. */
def player_free_selection_change_callback(player):    
    // Clean up the list for any removals
    player_remove_destroyed_free_words(player)

    // Look for any additions, tracking the most points seen for sound triggers
    let word = ""
    let max_points = 0
    let best_new_word = ∅
    let best_new_color = ∅
    for tile at t in player.free_row:
        word += tile.letter
        
    if dictionary[word]:
        if player.already_found[word] or player_free_row_contains(player, word):
            // Show that we've already seen this just-completed word by 
            // finding and emphasizing it
            player_emphasize_history_word(player, word)
        else:
            const points = score_word(word)
            const color = player_add_to_free(player, word, points)
            if points > max_points:
                max_points = points
                best_new_word = word
                best_new_color = color

    // At least one word was added
    if max_points > 0:
        player_spawn_free_score_animation(player, best_new_word, best_new_color)
        play_points_sound(max_points)
    
    // Choose the color based on the best selection
    max_points = 0
    for points in entry in player.history.free:
        max_points = max(max_points, points)

    if max_points > 0:
        return color_for_points(max_points) 
    else:
        return TILE_CENTER_SELECTED_COLOR



/* Creates animation going from the selection to the last word in the free list */
def player_spawn_free_score_animation(player, word, color):
    let target
    
    let letter_array = []
    let start_array = []
    
    const entry = player.history.free[find(player.history.free, {word: word}, ∅, word_property_equals)]
    assert(entry)
    
    // Have to wait until callback time for this so that the 
    // target actually gets rendered and assigned a pos first
    def capture_target():
        // Abort if the mode ends and history is cleared while 
        // waiting for this callback
        if not entry: return sequence.BREAK
        
        for i < size(word):
            const tile = player.free_row[i]
            
            if not tile or tile.letter ≠ word[i]: return sequence.BREAK
            
            push(start_array, xy(tile.pos))
            push(letter_array, q_decode(tile.letter))
        target = entry.pos + xy(4 size(entry.word), 4)


    def callback(frames_left, total_frames):
        const α = linstep(total_frames, 0, frames_left)^1.5
        for i < size(letter_array):
            const pos = lerp(start_array[i], target, α)
            draw_disk(pos, 12 * (1 - α), color, ∅, 9)
            draw_text({font: score_font, x_align: "center", y_align: "center", text: letter_array[i], pos: pos, color: rgba(1, 1, 1, 1 - α³), z: 10})
        
    sequence({begin_callback: capture_target, callback: callback, frames: POINTS_ANIMATION_FRAMES})



/* Remove any previous entry of player.history.free that does not belong */
def player_remove_destroyed_free_words(player):
    let word = ""
    for tile at t in player.free_row:
        word += tile.letter
        
    def maybe_remove(entry):
        if not starts_with(word, entry.word):
            todo("Sound and animation for removal")
            return iterate.REMOVE
        
    iterate(player.history.free, maybe_remove)
    
    
    
/* Add a tile to the free row */
def add_tile_to_word(index):
    const tile = player.board.tile[index.x][index.y]
    assert(not tile.used)    
    _board_play_sound(select_tile_sound, 85%, 100%, index)
    
    tile.used = true
    push(player.free_row, {
        letter: tile.letter,
        source_tile: tile,
        points: LETTER_POINT_TABLE[tile.letter]})
    
    selection_color = player_free_selection_change_callback(player, player.free_row)



/* Remove the last tile from the free row */
def remove_last_tile():
    remove_tile_at_index(size(player.free_row) - 1)
        


/* Remove a specific tile from the free row by index */
def remove_tile_at_index(index):
    assert(index ≥ 0 and index < size(player.free_row))
    const tile = player.free_row[index]
    // Put back into the board
    tile.source_tile.used = false

    // Remove from the player.free_row
    remove_values(player.free_row, tile)
    
    play_sound(select_tile_sound, false, 150%, ∅, 40%)

    // Update selection
    selection_color = player_free_selection_change_callback(player, player.free_row)



/* Draw the free word construction area. Returns the history rect
   because that is computed as a side effect of layout. */
def draw_free_row(board_pos)
& preserving_transform:
    // Move in front of the history
    set_transform(∅, ∅, 2)
    
    const [board_grid_size, board_tile_size, board_gutter] = get_free_round_board_dims()
    const board_width = board_grid_size.x + ¼ board_tile_size.x
    
    let history_rect = get_history_rect()
        
    // Choose tile size. Leave room for one extra tile until we hit 16
    // to imply that the player can keep going
    const tile_slots = clamp(size(player.free_row) + 1, if landscape() then 8 else 6, ROWS * COLS)
    
    const tile_area_width = if landscape() then board_grid_size.x else (history_rect.size.x - 10)
    
    let tile_size = xy(1, 1) * tile_area_width / tile_slots
    if tile_slots < ROWS * COLS:
        // Round up, we have some room
        tile_size = ceil(tile_size)
    else:
        // Have to make that last letter fit
        tile_size = round(tile_size)
        
    
    // Take off the padding
    if tile_size.x > 21:
        tile_size -= 1
        
    if tile_size.x ≥ 12:
        tile_size -= 1
        
    // Spacing between tiles
    const tile_spacing = tile_size.x + (if tile_size.x > 21 then 2 else (if tile_size.x > 12 then 1 else 0))

    const last_entry = last_value(player.history.free) default {word: "", color: TILE_CENTER_SELECTED_COLOR}
    let selection_length = size(last_entry.word)
    const selection_color = last_entry.color

    
    let free_rect
    if landscape():
        // Landscape: free over board
        free_rect = {
            corner: board_pos - xy(½ board_width, ½ board_width + tile_size.y + 14),
            size: xy(board_width, tile_size.y + 6)}
    else: 
        // Portrait: free over reduced history
        history_rect.size.y -= tile_size.y + 4
        
        free_rect = {
            corner: history_rect.corner + xy(1, history_rect.size.y),
            size: xy(history_rect.size.x - 2, tile_size.y + 6)}    
    
    draw_rect(free_rect.corner + ½ free_rect.size, free_rect.size, player.background_color, selection_color)
    // Double wide outline
    draw_rect(free_rect.corner + ½ free_rect.size, free_rect.size + 2, ∅, selection_color)
    draw_rect(free_rect.corner + ½ free_rect.size, free_rect.size + 4, ∅, selection_color)
        
    // Draw tiles in the word
    const start_x = free_rect.corner.x + ⌈½ tile_spacing⌉ + 2
    const tile_y = free_rect.corner.y + ⌊½ free_rect.size.y⌋

    let i = 0
    let removed_already = false
    while i < size(player.free_row):
        const tile = player.free_row[i]
        tile.pos = xy(start_x + i * tile_spacing, tile_y)
        
        tile.selected = i < selection_length
        tile_draw(tile, tile.pos, false, 0°, selection_color, tile_size, true)
        
        // Use touch.a instead of touch.pressed_a so that the player can swipe across
        // to remove all
        if not removed_already and touch.a and overlaps(touch.xy, {pos: tile.pos, size: tile_size}):
            --selection_length
            removed_already = true
            remove_tile_at_index(i)
        else:
            ++i
            
    for size(player.free_row) ≤ i < tile_slots:
        draw_rect(xy(start_x + i * tile_spacing, tile_y), tile_size - 2, TILE_HOLE_COLOR)
        
            
    // Draw the connectors between letters if it is a word. Intentionally
    // do not draw the selected-but-not-a-word line, as it makes them not 
    // look like tiles any more
    if selection_length > 1:
        draw_line(xy(start_x, tile_y), xy(start_x + (selection_length - 1) * tile_spacing, tile_y), selection_color, TILE_CENTER_Z, ¼ tile_size.y)

    return history_rect
    


/* Returns `[grid_size, tile_size, gutter]` for the
   Free Mode board, which is shrunk in landscape mode. */    
def get_free_round_board_dims():
    let tile_size = xy(TILE_EXTENT, TILE_EXTENT)
    
    if landscape():
        // Make the board smaller to make room for the free row.
        // The player may not notice as we blacked the screen
        // between rounds
        tile_size = ⌊85% tile_size⌋
        
    const gutter = ⌊tile_size.x / 8.8⌋
    const grid_size = xy(COLS, ROWS) * tile_size + xy(COLS - 1, ROWS - 1) * gutter

    return [grid_size, tile_size, gutter]



/* Draw the board with used tiles shown as blank */
def draw_free_round_board(pos)
& preserving_transform:
    // Duplicates some `player_update_board()` code because it has to draw
    // the board in a special way to make it smaller and have missing tiles

    const [grid_size, tile_size, gutter] = get_free_round_board_dims()
    const center_size = tile_size - gutter
    
    set_transform(pos)
    
    draw_rect(xy(0, 0), grid_size + ¼ tile_size.x, player.background_color, player.board.selection_color)
    draw_rect(xy(0, 0), grid_size + ¼ tile_size.x + 2, ∅, player.board.selection_color)
    draw_rect(xy(0, 0), grid_size + ¼ tile_size.x + 4, ∅, player.board.selection_color)
    
    for col at i in player.board.tile:
        for tile at j in col:
            const index = xy(i, j)
            const tile_pos = (index * (gutter * xy(min(index.x, 1), min(index.y, 1)) + tile_size.x) - ½ xy(COLS - 1, ROWS - 1) * (tile_size.x + gutter))
            const is_cursor_tile = player.using_gamepad and player.cursor_tile_index.x == i and player.cursor_tile_index.y == j
            
            tile.pos = transform_ws_to_ss(tile_pos)
            
            // Touch selection for adding tiles to word
            const tile_center = {pos: tile_pos, shape: "disk", size: center_size}
            if mode_frames > 5 and touch.a and overlaps(tile_center, touch.xy) and not tile.used:
                add_tile_to_word(index)
            
            // Gamepad selection
            if player.using_gamepad and is_cursor_tile:
                if player.gamepad.pressed_a and not tile.used:
                    add_tile_to_word(index)
                        
            if not tile.used:
                tile_draw(tile, tile_pos, is_cursor_tile, 0°, #CCC, tile_size)
            else:
                draw_rect(tile_pos, xy(35, 35), TILE_HOLE_COLOR)
                
                // Cursor on used tile: border only
                if is_cursor_tile:
                    for i < 2:
                        draw_rect(tile_pos, tile_size - 2 i, ∅, CURSOR_COLOR)



def draw_instructions(board_pos):
    draw_text({
        text: "Choose tiles in any order",
        pos: board_pos + (if landscape() then xy(-107, 46) else xy(0, 107)),
        x_align: if landscape() then "right" else "center",
        y_align: "top",
        color: #EEE,
        wrap_width: if landscape() then SCREEN_SIZE.x - 280 else ∅,
        shadow: #111,
        font: leaderboard_font})


def done():
    play_sound({sound: blip_alt_sound, volume: 80%})
    pop_mode() because "Button"


enter
────────────────────────────────────────────────────────────────────────
play_sound({sound: blip_alt_sound, pitch: 75%, volume: 80%})


frame
────────────────────────────────────────────────────────────────────────
maybe_connect_to_network()
const time_left = end_time - frame_utc_now

// Handle gamepad cursor movement
if player.using_gamepad:
    const target = player.cursor_tile_index + player.gamepad.xy * |sign(player.gamepad.dxy)|
    if target.x ≥ 0 and target.x < COLS and target.y ≥ 0 and target.y < ROWS:
        player.cursor_tile_index = target

const board_pos = get_board_pos()
// Draw timer, score, and back button in the usual height but squeeze
// closer to align
local:
    const offset = if landscape() then xy(16, 0) else xy(0, 0)
    draw_timer(board_pos + offset)
    player_update_back_button(player, board_pos - offset)
    player_draw_score(player, board_pos - offset)


if landscape():
    // Move the board down to make room for the free row
    board_pos.y += 17

// Draw the board with used tiles as blank
draw_free_round_board(board_pos)

// Draw free word construction area
const history_rect = draw_free_row(board_pos)

history_update(player.history, history_rect)

draw_instructions(board_pos)

handle_ability_button(0, "Free", "Done", action_icon.ok, "(q)", done)
    

if time_left ≤ 20/60:
    // Grace frames drawn in black
    draw_corner_rect(xy(0, 0), SCREEN_SIZE, #000, ∅, 100)

if time_left ≤ 0:
    // Go back to Play, which will then go to the intermission
    pop_mode() because "Timer"

