/* Common code across modes. Mostly UI and timing. */

/* Set by Title. `SOLO` or `GLOBAL`. See also `in_waiting_room` */
let game_type = SOLO

/* In seconds, using frame_utc_now */
let start_time

/* In seconds, using frame_utc_now */
let end_time


/* If true, then the player is just warming
   up for a `GLOBAL` game that will start soon. */
let in_waiting_room = false

let player = make_player()

let resolution_hook
let time_hook
let input_hook
let notification_hook

/* Set by `Play.enter`. Used to track games that should not affect stats */
let joined_late

const SOLO_GAME_TIME = 60 SOLO_GAME_TIME_MINUTES

const GLOBAL_INTERMISSION_TIME = GLOBAL_INTERMISSION_TIME_SECONDS
const GLOBAL_GAME_TIME = GLOBAL_GAME_TIME_SECONDS

/* Global games are synchronized to this clock, hitting this period exactly 
   relative to UTC Unix 0 time */
const GLOBAL_PERIOD = GLOBAL_GAME_TIME + GATHER_TIME_SECONDS + GLOBAL_INTERMISSION_TIME


/* Array of strings for background display on the title and avatar editor, by row. See `draw_background_words()`. */
const background_word_array = []


/* Used by Title and AvatarEditor */
def draw_background_words():
    for s at y in background_word_array:
        draw_text({
            font: tile_font,
            color: #333,
            text: s,
            pos: xy(sign((y mod 2) - 0.5) * 0.2 oscillate(game_frames, -2000, 2000) - 700, 22 y),
            x_align: "left",
            z: -2})
    

/* Updated once per frame by a frame hook. This ensures that there are no 
   race conditions within a frame because the time can only change 
   between frames */
let frame_utc_now = utc_now()


/* Time at which the last global game already started
   (or is about to start) */
def prev_global_game_utc_start_time():
    return floor(frame_utc_now, GLOBAL_PERIOD)



/* Time at which the next global game will start */
def next_global_game_utc_start_time():
    return round(frame_utc_now, GLOBAL_PERIOD)



def _update_frame_utc_now():
    const prev_time = frame_utc_now
    frame_utc_now = utc_now()
    
    if frame_utc_now - prev_time > 60 * REBOOT_TIME_MINUTES:
        reset_game()



/* Hook that automaticaly switches the detected input mechanism */
def detect_input():
    if player.gamepad.pressed_a or player.gamepad.pressed_q or player.gamepad.pressed_b or player.gamepad.xx or player.gamepad.yy:
        player.using_gamepad = true
    else if touch.dx or touch.dy or touch.pressed_a or touch.hover:
        // Used touch screen or mouse
        player.using_gamepad = false



def play_points_sound(points, index default ∅):
    const pitch = 75% + min(max(0, points - 6)^0.1, 3)
    _board_play_sound(word_sound, 100% + 10% pitch, pitch, index)

    // Repeatly ding for 35 or more points
    for i ≤ (points - 35) / 10:
        delay(play_big_points_sound, 12 i)



/* `true` if in landscape layout mode */
def landscape():
    return SCREEN_SIZE.x + 28 > SCREEN_SIZE.y

    
def set_hooks():
    if not notification_hook:
        notification_hook = add_frame_hook(update_notifications, ∅, ∞, "all")
    
    if not input_hook:
        input_hook = add_frame_hook(detect_input, ∅, ∞, "all")
    
    if not time_hook:
        time_hook = add_frame_hook(_update_frame_utc_now, ∅, ∞, "all")
        
    if not resolution_hook:
        // Fill the screen even at non-quadplay aspect ratios
        // for a good mobile experience. See also `DEBUG.PORTRAIT`
        device_control("set_mouse_cursor", "pointer")
        
        if DEBUG.LANDSCAPE:
            set_screen_size(xy(384, 224))
        else if DEBUG.PORTRAIT:
            device_control("enable_feature", "custom_screen_size")
            set_screen_size(xy(224, 400))
        else:
            resolution_hook = continuously_set_screen_size_to_window("smaller", 224)



/* Cooldown used in `draw_timer()`. Reset in `Play.enter` */
let last_countdown_sound_time

/* Draws the count-down timer for `end_time` relative to the board, and handles
   the countdown beeping and flashing. Returns distored time left. */
def draw_timer(board_pos):
    // Real seconds
    const real_time_left = max(0, end_time - frame_utc_now)
    
    // Remapped to shorten midgame and extend endgame tension
    let time_left = real_time_left
    
    if not in_waiting_room:
        // Varies per player because they may have entered late
        const game_total_time = end_time - start_time
        
        // Real time at which we pivot to expanding time
        const pivot = TIMER.REMAP_SECONDS / TIMER.END_TIME_SCALE
        
        // How much to scale time before the pivot
        const begin_time_scale = (game_total_time - pivot) / (game_total_time - TIMER.REMAP_SECONDS)
        
        if time_left > pivot:
            time_left = (time_left - pivot) * begin_time_scale + TIMER.REMAP_SECONDS
        else:
            time_left *= TIMER.END_TIME_SCALE
        
    // Display slightly less time than is actually available
    // so it doesn't feel like we're ending too abruptly on 0
    time_left -= 3/60
    
    const pos = board_pos + xy(-½, -½) * get_board_pixel_size() - xy(-28, 16)
    draw_text({
        pos: pos,
        font: score_font,
        text: format_number(time_left, "timer"),
        color: if in_waiting_room then #0F0 else #FFF,
        y_align: "center",
        x_align: "right"})
        
    if time_left > 0.1 and time_left < TIMER.BEEP_SECONDS + 0.5:
        if |loop(time_left, -0.5, 0.5)| ≤ 3/60 and now() - last_countdown_sound_time > 0.25:
            // Play on the second turnover exactly (so it aligns with the global clock instead of local frames)
            // but ensure that we play only once per timeout, converting from time to frames
            last_countdown_sound_time = now()
            play_sound(timer_countdown_sound, false, 150%)
            // Pulse in case sound is off
            player.background_color = #FFF
        else:
            // Fade back towards normal
            player.background_color = lerp(player.background_color, BOARD_COLOR, 4%)
    
    return time_left
    


def draw_round_selection(pos, radius):
    draw_disk(pos - xy(0, 1), radius + 0.5, ∅, #FFF, 2)
    draw_disk(pos - xy(0, 1), radius + 1.5, CURSOR_COLOR, ∅, -0.5)
    draw_disk(pos - xy(0, 1), radius + 4.5, rgba(CURSOR_COLOR, 25%), ∅, -0.6)
    draw_disk(pos - xy(0, 1), radius + 7.5, rgba(CURSOR_COLOR, 15%), ∅, -0.7)



def handle_ability_button(index, name, caption, sprite, gamepad_button, activate_callback):
    
    const radius = 14
    const region = {
        pos: xy(radius + 4 + 48 index, SCREEN_SIZE.y - radius - 1),
        size: radius * xy(2, 2),
        shape: "disk"}
    
    // First call this frame for any button; deselect all on hover
    if touch.hover and game_frames > handle_ability_button.last_frame:
        handle_ability_button.selected_button = ∅
    handle_ability_button.last_frame = game_frames

    if touch.hover and overlaps(region, touch.hover) and not player.using_gamepad:
        handle_ability_button.selected_button = name
        
    if handle_ability_button.selected_button ≠ name:
        draw_disk(region.pos, radius, #EEE)
    
    draw_text({
        pos: region.pos - xy(0, ½ region.size.y + 7),
        font: leaderboard_font,
        color: if handle_ability_button.selected_button == name then #FFF else #EEE,
        outline: if handle_ability_button.selected_button == name then rgba(CURSOR_COLOR, 50%) else ∅,
        text: caption})
    
    draw_sprite(sprite, region.pos)
    
    if player.using_gamepad:
        draw_text({
            pos: region.pos + xy(80% radius, 70% radius), 
            color: #fff,
            outline: #000,
            font: score_font,
            x_align: "left",
            z: 20,
            text: joy.prompt[gamepad_button]})
        
    if handle_ability_button.selected_button == name:
        draw_round_selection(region.pos, radius)
        
    if (mode_frames > 10 and 
        ((touch.pressed_a and overlaps(touch.xy, region))
        or joy.pressed_q)):
        activate_callback()

handle_ability_button.last_frame = 0


/* Abstracted to make an argument-less callback */
def play_big_points_sound():
    play_sound(big_points_sound)

//////////////////////////////////////////////////////////////////////////////////////////////////


// Initialize the background words
for y < 20:
    let s = random_safe_word()
    while size(s) < 250:
        s += " " + random_safe_word()
    background_word_array[y] = s

