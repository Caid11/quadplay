/* Popup notification system. Only shows one at a time and enqueues the rest.
   This code has some fonts hardcoded but is intended to be generalized towards
   eventually becoming a library independent of the game. */


// The notification at the front of the queue is currently displayed
const _notification_queue = []


def notify(sprite, title, description, begin_callback default ∅, duration_seconds default 4):
    assert(begin_callback == ∅ or type(begin_callback) == "function")
    
    push(_notification_queue, {
        sprite:         sprite,
        title:          title,
        description:    description,
        begin_callback: begin_callback,
        // Real time of display
        first_shown:    ∅,
        duration_seconds: duration_seconds})
    

    
def notifications_pending():
    return size(_notification_queue)    
    
    

/* Hook to process notification animation every frame */
def update_notifications()
& preserving_transform:
    // Draw way on top of everything in Z
    set_transform(xy(½ SCREEN_SIZE.x, 40), ∅, 110)
    
    const BACKGROUND_COLOR = #EEE
    const TITLE_FONT       = score_font
    const DESCRIPTION_FONT = leaderboard_font

    // These count against duration_seconds
    const ENTER_DURATION_SECONDS   = 0.17
    const EXIT_DURATION_SECONDS    = 0.17
        
    // Nothing to do
    if not notifications_pending(): return

    // Peek the queue
    const notification = _notification_queue[0]
    with first_shown, duration_seconds, sprite, begin_callback in notification:
        // Does not count against duration_seconds
        const DELAY_AFTER_SECONDS      = clamp(25% duration_seconds, 0.6, 1.2)
        
        const time_now = now()
        
        if first_shown == ∅:
            first_shown = time_now
            if begin_callback:
                begin_callback()

        const relative_time = time_now - first_shown    
        if relative_time > duration_seconds:        
            if relative_time > duration_seconds + DELAY_AFTER_SECONDS:
                // Done! remove
                pop_front(_notification_queue)
                
            return
        
        // Size fraction
        let α = 100%        
        if relative_time < ENTER_DURATION_SECONDS:
            // Grow
            α = clamp(relative_time / ENTER_DURATION_SECONDS, 0%, 100%)
        else if relative_time > EXIT_DURATION_SECONDS:
            // Shrink
            α = clamp((duration_seconds - relative_time) / EXIT_DURATION_SECONDS, 0%, 100%)

        
        const rect = {pos: xy(0, 0), size: α * xy(204, 60)}
        // Drop shadow
        draw_rect(rect.pos + xy(0, 4), rect.size + 4, #0008, ∅, ∅, -1)

        // Window
        draw_rect(rect.pos, rect.size, BACKGROUND_COLOR, #E1B)
        draw_rect(rect.pos, rect.size - 2, ∅, #E1B)
        draw_rect(rect.pos, rect.size + 2, ∅, #000)
        
        if α == 100%:
            // Show contents when the window is full size
            const sprite_width = 32
            const padding = 7
            const text_width = rect.size.x - sprite_width - 2.5 padding 

            draw_sprite({
                sprite: notification.sprite,
                pos: xy(-½ rect.size.x + padding + ½ sprite_width, 0),
                override_color: if equivalent(rgb(notification.sprite.mean_color), #FFF) then #000 else ∅,
                scale: sprite_width / notification.sprite.size.x})
    
            draw_text({
                text: "{font:" + TITLE_FONT + " {color:#E1B " + notification.title + "}{br}}" + notification.description,
                pos: xy(-½ rect.size.x + sprite_width + 2 padding, 0),
                font: DESCRIPTION_FONT,
                color: #000,
                markup: true,
                wrap_width: text_width,
                x_align: "left",
                y_align: "center"})


