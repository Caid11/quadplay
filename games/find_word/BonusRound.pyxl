BonusRound
════════════════════════════════════════════════════════════════════════

/* Tiles for the bonus word construction */
let bonus_row = []

let selection_color = TILE_CENTER_SELECTED_COLOR

/* Computed in `enter` */
let bonus_round_text


/* Searches player.history.bonus for the word */
def player_already_found_bonus(player, word):
    return contains(player.history.bonus, {word: word}, word_property_equals)



def player_update_back_button(player, board_pos):
    if size(bonus_row):
        player_update_aux_button(player, board_pos, remove_last_tile, shapes.arrow.x_flipped, "b", ∅, true)



/* Recompute `player.history.bonus` from `bonus_row` and return the `bonus_selection_color`.
   See also `player_selection_change_callback()` for the `Play` mode. */
def player_bonus_selection_change_callback(player, bonus_row):    
    // Clean up the list for any removals
    player_remove_destroyed_bonus_words(player, bonus_row)

    // Look for any additions, tracking the most points seen for sound triggers
    let word = ""
    let max_points = 0
    let best_new_word = ∅
    let best_new_color = ∅
    for tile at t in bonus_row:
        word += tile.letter
        if dictionary[word] and not player_already_found_bonus(player, word):
            if player.already_found[word]:
                if t == size(bonus_row):
                    // Show that we've already seen this just-completed word by 
                    // finding and emphasizing it
                    player_emphasize_history_word(player, word)
                    play_sound(select_tile_sound, false, 150%, ∅, 40%)
            else:
                const points = score_word(word)
                const color = player_add_to_bonus(player, word, points)
                if points > max_points:
                    max_points = points
                    best_new_word = word
                    best_new_color = color

    // At least one word was added
    if max_points > 0:
        player_spawn_bonus_score_animation(player, best_new_word, best_new_color)
        play_points_sound(max_points)
    
    // Choose the color based on the best selection
    max_points = 0
    for points in entry in player.history.bonus:
        max_points = max(max_points, points)

    if max_points > 0:
        return color_for_points(max_points) 
    else:
        return TILE_CENTER_SELECTED_COLOR



/* Creates animation going from the selection to the last word in the bonus list */
def player_spawn_bonus_score_animation(player, word, color):
    let target
    
    let letter_array = []
    let start_array = []
    
    const entry = player.history.bonus[find(player.history.bonus, {word: word}, ∅, word_property_equals)]
    assert(entry)
    
    // Have to wait until callback time for this so that the 
    // target actually gets rendered and assigned a pos first
    def capture_target():
        // Abort if the mode ends and history is cleared while 
        // waiting for this callback
        if not entry: return sequence.BREAK
        
        for i < size(word):
            const tile = bonus_row[i]
            
            if not tile or tile.letter ≠ word[i]: return sequence.BREAK
            
            push(start_array, xy(tile.pos))
            push(letter_array, q_decode(tile.letter))
        target = entry.pos + xy(4 size(entry.word), 4)


    def callback(frames_left, total_frames):
        const α = linstep(total_frames, 0, frames_left)^1.5
        for i < size(letter_array):
            const pos = lerp(start_array[i], target, α)
            draw_disk(pos, 12 * (1 - α), color, ∅, 9)
            draw_text({font: score_font, x_align: "center", y_align: "center", text: letter_array[i], pos: pos, color: rgba(1, 1, 1, 1 - α³), z: 10})
        
    sequence({begin_callback: capture_target, callback: callback, frames: POINTS_ANIMATION_FRAMES})



/* Remove any previous entry of player.history.bonus that does not belong */
def player_remove_destroyed_bonus_words(player, bonus_row):
    let word = ""
    for tile at t in bonus_row:
        word += tile.letter
        
    def maybe_remove(entry):
        if not starts_with(word, entry.word):
            todo("Sound and animation for removal")
            return iterate.REMOVE
        
    iterate(player.history.bonus, maybe_remove)
    
    
    
/* Add a tile to the bonus row */
def add_tile_to_word(index):
    const tile = player.board.tile[index.x][index.y]
    assert(not tile.used)
    
    tile.used = true
    push(bonus_row, {
        letter: tile.letter,
        index: xy(index),
        points: LETTER_POINT_TABLE[tile.letter]})
    
    selection_color = player_bonus_selection_change_callback(player, bonus_row)



/* Remove the last tile from the bonus row */
def remove_last_tile():
    remove_tile_at_index(size(bonus_row) - 1)
        


/* Remove a specific tile from the bonus row by index */
def remove_tile_at_index(index):
    assert(index ≥ 0 and index < size(bonus_row))
    const tile = bonus_row[index]
    // Put back into the board
    player.board.tile[tile.index.x][tile.index.y].used = false

    // Remove from the bonus_row
    remove_values(bonus_row, tile)
    
    play_sound(select_tile_sound, false, 150%, ∅, 40%)

    // Update selection
    selection_color = player_bonus_selection_change_callback(player, bonus_row)



/* Draw the bonus word construction area. Returns the history rect
   because that is computed as a side effect of layout. */
def draw_bonus_row(board_pos):
    todo("Show empty tile slots on bonus row")

    const [board_grid_size, board_tile_size, board_gutter] = get_bonus_round_board_dims()
    const board_width = board_grid_size.x + ¼ board_tile_size.x
    
    let history_rect
    if landscape():
        history_rect = {corner: xy(1, 5), size: xy(board_pos.x - ½ board_pixel_size().x - ¼ TILE_EXTENT + 1, SCREEN_SIZE.y - 8)}
    else:
        history_rect = {corner: xy(1, 1), size: xy(SCREEN_SIZE.x - 2, board_pos.y - ½ board_pixel_size().y - 32)}
        
    // Choose tile size. Leave room for one extra tile until we hit 16
    // to imply that the player can keep going
    const tile_slots = clamp(size(bonus_row) + 1, if landscape() then 8 else 6, ROWS * COLS)
    
    const tile_area_width = if landscape() then board_grid_size.x else (history_rect.size.x - 10)
    
    let tile_size = xy(1, 1) * tile_area_width / tile_slots
    if tile_slots < ROWS * COLS:
        // Round up, we have some room
        tile_size = ceil(tile_size)
    else:
        // Have to make that last letter fit
        tile_size = round(tile_size)
        
    
    // Take off the padding
    if tile_size.x > 21:
        tile_size -= 1
        
    if tile_size.x ≥ 12:
        tile_size -= 1
        
    // Spacing between tiles
    const tile_spacing = tile_size.x + (if tile_size.x > 21 then 2 else (if tile_size.x > 12 then 1 else 0))

    const last_entry = last_value(player.history.bonus) default {word: "", color: TILE_CENTER_SELECTED_COLOR}
    let selection_length = size(last_entry.word)
    const selection_color = last_entry.color

    
    let bonus_rect
    if landscape():
        // Landscape: bonus over board
        bonus_rect = {
            corner: board_pos - xy(½ board_width, ½ board_width + tile_size.y + 14),
            size: xy(board_width, tile_size.y + 6)}
    else: 
        // Portrait: bonus over reduced history
        history_rect.size.y -= tile_size.y + 4
        
        bonus_rect = {
            corner: history_rect.corner + xy(1, history_rect.size.y),
            size: xy(history_rect.size.x - 2, tile_size.y + 6)}    
    
    draw_rect(bonus_rect.corner + ½ bonus_rect.size, bonus_rect.size, player.background_color, selection_color)
    // Double wide outline
    draw_rect(bonus_rect.corner + ½ bonus_rect.size, bonus_rect.size + 2, ∅, selection_color)
    draw_rect(bonus_rect.corner + ½ bonus_rect.size, bonus_rect.size + 4, ∅, selection_color)
        
    // Draw tiles in the word
    const start_x = bonus_rect.corner.x + ⌈½ tile_spacing⌉ + 2
    const tile_y = bonus_rect.corner.y + ⌊½ bonus_rect.size.y⌋

    let i = 0
    let removed_already = false
    while i < size(bonus_row):
        const tile = bonus_row[i]
        tile.pos = xy(start_x + i * tile_spacing, tile_y)
        
        tile.selected = i < selection_length
        tile_draw(tile, tile.pos, false, 0°, selection_color, tile_size, true)
        
        if not removed_already and touch.pressed_a and overlaps(touch.xy, {pos: tile.pos, size: tile_size}):
            --selection_length
            removed_already = true
            remove_tile_at_index(i)
        else:
            ++i
            
    // Draw the connectors between letters if it is a word. Intentionally
    // do not draw the selected-but-not-a-word line, as it makes them not 
    // look like tiles any more
    if selection_length > 1:
        draw_line(xy(start_x, tile_y), xy(start_x + (selection_length - 1) * tile_spacing, tile_y), selection_color, TILE_CENTER_Z, ¼ tile_size.y)

    return history_rect
    


/* Returns `[grid_size, tile_size, gutter]` for the
   bonus round board, which is shrunk in landscape mode. */    
def get_bonus_round_board_dims():
    let tile_size = xy(TILE_EXTENT, TILE_EXTENT)
    
    if landscape():
        // Make the board smaller to make room for the bonus row.
        // The player may not notice as we blacked the screen
        // between rounds
        tile_size = ⌊85% tile_size⌋

    const gutter = ⌊tile_size.x / 9⌋
    const grid_size = xy(COLS, ROWS) * tile_size + xy(COLS - 1, ROWS - 1) * gutter
    return [grid_size, tile_size, gutter]



/* Draw the board with used tiles shown as blank */
def draw_bonus_round_board(pos)
& preserving_transform:
    // Duplicates some `player_update_board()` code because it has to draw
    // the board in a special way to make it smaller and have missing tiles

    const [grid_size, tile_size, gutter] = get_bonus_round_board_dims()
    const center_size = tile_size - 5
    
    set_transform(pos)
    
    draw_rect(xy(0, 0), grid_size + ¼ tile_size.x, player.background_color, player.board.selection_color)
    draw_rect(xy(0, 0), grid_size + ¼ tile_size.x + 2, ∅, player.board.selection_color)
    draw_rect(xy(0, 0), grid_size + ¼ tile_size.x + 4, ∅, player.board.selection_color)
    
    for col at i in player.board.tile:
        for tile at j in col:
            const index = xy(i, j)
            const tile_pos = (index * (gutter * xy(min(index.x, 1), min(index.y, 1)) + tile_size.x) - ½ xy(COLS - 1, ROWS - 1) * (tile_size.x + gutter))
            const is_cursor_tile = player.using_gamepad and player.cursor_tile_index.x == i and player.cursor_tile_index.y == j
            
            tile.pos = transform_ws_to_ss(tile_pos)
            
            // Touch selection for adding tiles to word
            const tile_center = {pos: tile_pos, shape: "disk", size: center_size}
            if mode_frames > 5 and touch.a and overlaps(tile_center, touch.xy) and not tile.used:
                add_tile_to_word(index)
            
            // Gamepad selection
            if player.using_gamepad and is_cursor_tile:
                if player.gamepad.pressed_a and not tile.used:
                    add_tile_to_word(index)
                        
            if not tile.used:
                tile_draw(tile, tile_pos, is_cursor_tile, 0°, #CCC, tile_size)
            else:
                draw_rect(tile_pos, xy(35, 35), 90% player.background_color)
                
                // Cursor on used tile: border only
                if is_cursor_tile:
                    for i < 2:
                        draw_rect(tile_pos, tile_size - 2 i, ∅, CURSOR_COLOR)



def draw_instructions(board_pos):
    const args = {text: "Choose tiles in any order for one bonus word", color: #CCC, shadow: #111}
    if landscape():
    else:
        // Portrait
        draw_text({…args, font: leaderboard_font, pos: ½(xy(½ SCREEN_SIZE.x, SCREEN_SIZE.y) + board_pos + xy(0, 100)), wrap_width: SCREEN_SIZE.x - 10})


def done():
    for points in entry in player.history.bonus:        
        player.score += points
    
    // Reset the scroll position because layout differs
    // from the main game during intermission
    play_sound(times_up_sound)
    sort(player.history.list, "points", true)
    player.history.scroll = 0
    
    if game_type == SOLO:
        set_mode(SoloIntermission) because "SOLO and timer"
    else:
        set_mode(GatherGlobalResults) because "GLOBAL and timer"
    


enter
────────────────────────────────────────────────────────────────────────
// Assumes end_time was previously set by `Play`
end_time += bonus_round_time()

// Skip this mode entirely if there is no bonus time
if frame_utc_now ≥ end_time: done()

play_sound(bonus_round_sound)

bonus_row = []

bonus_round_text = ""
const text = "BONUS ROUND"
for letter at i in text:
    const α = i / (size(text) - 1)
    if letter == " ":
        bonus_round_text += " "
    else:
        bonus_round_text += "{color:" + unparse(perceptual_lerp_color(#E1B, #0AE, α)) + " " + letter + "}"



frame
────────────────────────────────────────────────────────────────────────
const time_left = end_time - frame_utc_now

// Handle gamepad cursor movement
if player.using_gamepad:
    const target = player.cursor_tile_index + player.gamepad.xy * |sign(player.gamepad.dxy)|
    if target.x ≥ 0 and target.x < COLS and target.y ≥ 0 and target.y < ROWS:
        player.cursor_tile_index = target

const board_pos = get_board_pos()
// Draw timer, score, and back button in the usual height but squeeze
// closer to align
local:
    const offset = if landscape() then xy(16, 0) else xy(0, 0)
    draw_timer(board_pos + offset)
    player_update_back_button(player, board_pos - offset)
    player_draw_score(player, board_pos - offset)
        
    todo("Draw score!")

if landscape():
    // Move the board down to make room for the bonus row
    board_pos.y += 17

// Draw the board with used tiles as blank
draw_bonus_round_board(board_pos)

// Draw bonus word construction area
const history_rect = draw_bonus_row(board_pos)

history_update(player.history, history_rect)

// Draw the bonus round animation over the history
preserving_transform:
    set_clip(history_rect)
        
    draw_text({
        font: giant_score_font,
        text: bonus_round_text,
        pos: xy(history_rect.corner.x + 1.2 history_rect.size.x - 2 mode_frames, history_rect.corner.y + ½ history_rect.size.y),
        x_align: "left",
        markup: true,
        outline: #FFF,
        shadow: #000})

draw_instructions(board_pos)

if time_left ≤ 0: done()

