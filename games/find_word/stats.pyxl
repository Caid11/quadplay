
/* A `stats` object contains `{lifetime: stats_entry, <date>: stats_entry, …, word_list: []}` */
def make_empty_stats_entry():
    return {
        longest_text: "",
        best_free_word_text: "", 
        best_free_word_points: 0,
        best_word_text: "", 
        best_word_points: 0,
        best_score: 0,
        most_words: 0,
        words: 0,
        points: 0,
        matches: 0,
        word_list: [],
        xp: 0}
        


def stats_total_xp(stats):
    let xp = 0
    for entry in stats:
        xp += entry.xp
    return xp
    
    

/* Assumes the input is a list of q-encoded, all-caps words. 
   Returns a string packing them into a form that serializes
   efficiently.
   
   quadplay limits the length of serialized save_local values, so
   compress by
   
   - Using a single string, eliminating an extra comma and quote from each word
   - Using suffix encoding for variants with trivial plurals:
       - § = + ES
       - $ = + S
   */
def compress_word_list(array):
    def length(a, b):
        return size(a) - size(b)
    
    const PRESENT = 2
    const ALREADY_SAVED = 1
    
    // Start with words sorted from longest to shortest
    // (so we see prefixes first), and then mark all present
    array = sorted(array, length, true)

    // Maps each word to PRESENT or ALREADY_SAVED
    let set = {}
    for i < size(array):
        set[array[i]] = PRESENT
        
    // Encode the words of array. Process in order from longest
    // to shortest so that suffix encodings work
    const dest = []    
    
    for i < size(array):
        const text = array[i]
        if set[text] ≠ ALREADY_SAVED:
            // Technically unnecessary; we won't return to this word
            set[text] = ALREADY_SAVED
            
            // Because of the way that the game scores words,
            // it is actually impossible to have found the suffix
            // plural without the singular. However, this logic is good
            // for later generalizing to other suffixes
            // and prefixes.
            const strip2 = slice(text, 0, size(text) - 2)
            const strip1 = slice(text, 0, size(text) - 1)
            if ends_with(text, "ES") and set[strip2] == PRESENT:
                set[strip2] = ALREADY_SAVED
                push(dest, strip2 + "&")
            else if ends_with(text, "S") and set[strip1] == PRESENT:
                set[strip1] = ALREADY_SAVED
                push(dest, strip1 + "$")
            else:
                push(dest, text)
    
    // Allow array and set to be garbage collected before we compute a giant
    // string.
    set = ∅
    array = ∅    
        
    // Perform a single join at the end instead of string concatenation as we go
    // so that native code can do this more efficiently
    return COMPRESSED_HEADER + string_compress(join(dest, ","))
    
    

/* Returns an array of Q-encoded words */
def decompress_word_list(string):
    assert(string ≠ ∅)
    
    if string == "": return []
    
    if starts_with(string, COMPRESSED_HEADER):
        // Compressed with LZ as well. All current save games have this
        // but legacy files do not
        string = string_decompress(slice(string, size(COMPRESSED_HEADER)))
    
    const result = []
    const array = split(string, ",")
    for i < size(array):
        let text = array[i]
        if ends_with(text, "$"):
            text = slice(text, 0, size(text) - 1)
            push(result, text + "S")
        else if ends_with(text, "&") or ends_with(text, "§"):
            // § is legacy support. Avoiding unicode characters
            // increases our compression options
            text = slice(text, 0, size(text) - 1)
            push(result, text + "ES")
            
        push(result, text)
    
    return result
    


def stats_save(stats):
    const s = deep_clone(stats)
    for day at date in s:
        day.xp = encode_xp(day.xp)
        day.word_list = compress_word_list(day.word_list)
    save_local("stats", s)
    
    

/* Returns a new stats object loaded from storage. */
def stats_load():
    const stats = load_local("stats") default {lifetime: make_empty_stats_entry()}
    if not size(stats.lifetime.word_list): stats.lifetime.word_list = ""

    // Clean up and decode all entries
    for day at date in stats:
        day.xp = decode_xp(day.xp)
        day.word_list = decompress_word_list(day.word_list default "")
                
        if day.best_free_word_points == ∅:
            day.best_free_word_points = 0
            day.best_free_word_text = ""

        // Upgrade legacy formats
        if day.longest ≠ ∅:
            remove_key(day, "longest")
        
        if day.longest_text == ∅:
            day.longest_text = ""
                
    // Everything is decoded now. Iterate again to merge any
    // days before today
    stats_merge_previous_days(stats)
    
    return stats



/* Roll up every day other than today into the lifetime stats, and
   then delete those days.
*/
def stats_merge_previous_days(stats):
    const today_date = today_date_string(true)
    const lifetime = stats.lifetime
    
    if not stats[today_date]:
        stats[today_date] = make_empty_stats_entry()
                
    for date in keys(stats):
        // Skip the elements we are not modifying
        if date == "lifetime" or date == today_date: continue
    
        const day = stats[date]
                    
        if size(day.longest_text) > size(lifetime.longest_text):
            lifetime.longest_text = day.longest_text
            
        if day.best_word_points > lifetime.best_word_points:
            lifetime.best_word_points = day.best_word_points
            lifetime.best_word_text = day.best_word_text

        if day.best_free_word_points > lifetime.best_free_word_points:
            lifetime.best_free_word_points = day.best_free_word_points
            lifetime.best_free_word_text = day.best_free_word_text

        lifetime.most_words = max(lifetime.most_words, day.most_words)
        lifetime.best_score = max(lifetime.best_score, day.best_score)
        lifetime.words += day.words
        lifetime.points += day.points
        lifetime.matches += day.matches
        lifetime.xp += day.xp
        push(lifetime.word_list, …day.word_list)
        
        // Remove this rolled up day
        remove_key(stats, date)

        return stats
    
    
    
/* Used for lightly protecting the saved value from casual abuse via a checksum */
def encode_xp(xp):
    let h = "" + hash(xp)
    h = slice(h, 2)
    return h + "." + xp
        
        
        
/* Used for lightly protecting the saved value from casual abuse via a checksum */
def decode_xp(str):
    if DEBUG.GRANT_ALL_ABILITIES:
        return 60000
    
    if type(str) ≠ "string":
        // Was not properly encoded
        return 0

    // Decode and then re-encode and verify match
    const xp = parse(split(str, ".")[1])
    return if (encode_xp(xp) == str) then xp else 0
    

/* Don't let the value change except when stats are updated in
   `stats_merge_previous_days()`, otherwise we'll access uncollected data. */
let today_date = ∅
def today_date_string(update default false):
    if update:
        const date = local_time()
        today_date = "" + date.year + "-" + (date.month + 1) + "-" + date.day
    return today_date



/* 
    Update the player's stats and level given the results in 
    competitor from a global match. Does not save.
    
    Returns a list of new unique words
*/
def stats_update(stats, competitor, joined_late):

    // We may have passed midnight, so roll up any previous days
    // if needed before updating today's entry
    stats_merge_previous_days(stats)

    assert(stats)
    
    const entry = stats[today_date_string()]
    
    if size(competitor.longest_text) > size(entry.longest_text):
        entry.longest_text = competitor.longest_text

    if competitor.best_free_word_points > (entry.best_free_word_points default 0):
        entry.best_free_word_points = competitor.best_free_word_points
        entry.best_free_word_text = competitor.best_free_word_text
        
    if competitor.best_word_points > entry.best_word_points:
        entry.best_word_points = competitor.best_word_points
        entry.best_word_text = competitor.best_word_text
    
    entry.best_score = max(competitor.score, entry.best_score)
    
    
    const N = size(competitor.word_list) + size(competitor.free_list)
    if N > entry.most_words:
        entry.most_words = N
    
    if not joined_late:
        entry.words += N
        entry.points += competitor.score
        ++entry.matches
    
    entry.xp += ⌈competitor.score * XP_VALUE.point⌉

    // Accumulate the words previously found by this player
    const word_set = {}
    for list in [stats.lifetime.word_list, entry.word_list]: 
        for word in list:
            word_set[word] = 1
    
    // Add the new words
    const unique = []
    for list in [competitor.word_list, competitor.free_list]:
        for word in list:
            if not word_set[word]:
                push(entry.word_list, word)
                push(unique, word)
    
    sort(entry.word_list)
    
    return unique
    
    

/* Returns the region */
def draw_stats_button(pos, selected, radius):
    const scale = radius / 20
    const sprite_args = {sprite: stats_sprite[0][0], pos: pos, z: 10, scale: scale}
    
    if selected:
        draw_round_selection(pos, radius)
        // Outline
        for i < 2:
            draw_sprite({…sprite_args, pos: pos + xy(2i - 1, 0), override_color: #090})    
            draw_sprite({…sprite_args, pos: pos + xy(0, 2i - 1), override_color: #090})    
        draw_sprite({…sprite_args, override_color: #EEE})    
    else:
        // Background
        draw_disk(pos, radius, #FFFC, #DDD, 9)
        draw_sprite(sprite_args)    
        
    draw_text({
        font: score_font, 
        text: "Stats", 
        color: if selected then #FFF else #EEE,
        outline: if selected then rgba(CURSOR_COLOR, 50%) else ∅,
        shadow: #000, 
        pos: pos + xy(0, 27),
        z: 100})

    if not player.has_achievement["Check Stats"]:
        draw_tutorial(pos - xy(0, radius), "Check\nStats")

    return {pos: pos, shape: "disk", size: radius * xy(2, 2)}        
  

    