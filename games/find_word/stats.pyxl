/* See `xp_to_level()`. Chosen to make Level 20 = 100k XP */
const LEVEL_EXPONENT = 0.65

/* See `xp_to_level()` */
const LEVEL_DIVISOR  = 1000


const XP_VALUE = {
    // Per point
    point: 0.2,
    
    // Per day
    //day: 100,
    
    // For each badge
    //badge: 50
}


def xp_to_level(xp):
    assert(xp ≠ ∅ and not is_nan(xp))
    return floor((xp / LEVEL_DIVISOR + ½)^LEVEL_EXPONENT + 1)



/* XP needed to reach this level */
def level_to_xp(level):
    if level ≤ 0:
        return 0
    else:
        return floor((level - 1)^(1 / LEVEL_EXPONENT) * LEVEL_DIVISOR, ½ LEVEL_DIVISOR)

/*
for 1 ≤ level ≤  10:
    const xp = level_to_xp(level)
    debug_print(level, xp, xp_to_level(xp + 0))*/


def make_empty_stats_entry():
    return {
        longest_text: "", 
        best_word_text: "", 
        best_word_points: 0,
        best_score: 0,
        most_words: 0,
        words: 0,
        points: 0,
        matches: 0,
        xp: 0}



def stats_save(stats):
    const s = deep_clone(stats)
    for day in s:
        day.xp = encode_xp(day.xp)
    save_local("stats", s)
    
    

/* Returns a new stats object, which may have zeros */
def stats_load():    
    const stats = load_local("stats") default {lifetime: make_empty_stats_entry()}
    stats.word_list = stats.word_list default []
    
    for day in stats:
        day.xp = decode_xp(day.xp)
        // Upgrade
        if day.longest ≠ ∅:
            remove_key(day, "longest")
        if day.longest_text == ∅:
            day.longest_text = ""
        
    return stats
    
    
    
/* Used for lightly protecting the saved value from casual abuse via a checksum */
def encode_xp(xp):
    let h = "" + hash(xp)
    h = slice(h, 2)
    return h + "." + xp
        
        
        
/* Used for lightly protecting the saved value from casual abuse via a checksum */
def decode_xp(str):
    if type(str) ≠ "string":
        // Was not properly encoded
        return 0
        
    const xp = parse(split(str, ".")[1])
    if encode_xp(xp) == str:
        return xp
    else:
        // Was not properly encoded
        return 0
    


def today_date_string():
    const date = local_time()
    return "" + date.year + "-" + (date.month + 1) + "-" + date.day



/* 
    Update the player's stats and level given the results in 
    competitor from a global match. Do not save.
*/
def player_change_stats(player, competitor)
& with stats in player:

    assert(stats)
    assert(stats.lifetime)
    assert(stats.word_list ≠ ∅)
    
    // Today's date in the local time zone
    const date = today_date_string()
    
    // Remove any previous date values
    for key in keys(stats):
        if key ≠ "lifetime" and key ≠ date and key ≠ "word_list":
            remove_key(stats, key)
    
    // Update lifetime and today
    for entry_name in ["lifetime", date]:
        
        if not stats[entry_name]:
            // No record, so update it
            stats[entry_name] = make_empty_stats_entry()
            
        // Update result
        const entry = stats[entry_name]
        if size(competitor.longest_text) > size(entry.longest_text):
            entry.longest_text = competitor.longest_text
            
        if competitor.best_word_points > entry.best_word_points:
            entry.best_word_points = competitor.best_word_points
            entry.best_word_text = competitor.best_word_text
            
        if competitor.score > entry.best_score:
            entry.best_score = competitor.score
        
        const N = size(competitor.word_list)
        if N > entry.most_words:
            entry.most_words = N
        
        entry.words += N
        entry.points += competitor.score
        ++entry.matches
        
        entry.xp += ⌈competitor.score * XP_VALUE.point⌉

    // Accumulate the words found by this player
    const word_set = {}
    for word in player.stats.word_list:
        word_set[word] = 1
    
    for word in competitor.word_list:
        if not word_set[word]:
            push(stats.word_list, word)
    
    sort(stats.word_list)
    player.avatar.level = xp_to_level(stats.lifetime.xp)

    