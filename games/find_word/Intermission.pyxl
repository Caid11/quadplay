Intermission
════════════════════════════════════════════════════════════════════════

let unfound_word

def points_order(A, B):
    return B.points - A.points
    
    
def word_comparator(entry, word):
    return entry.word == word
    

def choose_unfound_word():
    for i < 30:
        unfound_word = random_value(player.board.word_list)
        if not sensitive[unfound_word] and not contains(player.history.list, unfound_word, word_comparator):
            return
    
    unfound_word = ∅
    

let end_time

enter
────────────────────────────────────────────────────────────────────────
set_background(#333)
board_deselect_all(player.board, player)
//debug_print(player.board.word_list)
sort(player.history.list, points_order)

if game_type == SOLO:
    end_time = utc_time + SOLO_INTERMISSION_TIME
else:    
    end_time = next_global_game_utc_start_time()

frame
────────────────────────────────────────────────────────────────────────

if mode_frames mod 550 == 120:
    choose_unfound_word()
    
const left = if landscape() then ⅓ else ¼
const right = 100% - left

// Score
draw_text({
    font: score_font,
    text: format_number(player.score, "commas") + " pts",
    outline: #000,
    shadow: #000,
    pos: xy(left * SCREEN_SIZE.x, 18),
    color: #FFF})

draw_text({
    font: history_font,
    text: "" + size(player.history.list) + "/" + player.board.word_count + " words found",
    pos: xy(left * SCREEN_SIZE.x, 32),
    shadow: #000,
    color: #FFF})
    

if unfound_word:
    draw_text({
        font: history_font,
        text: "Try \"" + unfound_word + "\"",
        pos: xy(left *  SCREEN_SIZE.x, 42),
        shadow: #000,
        color: #FFF})
    
// Board
for y < ROWS:
    for x < COLS:
        const pos = xy(right * SCREEN_SIZE.x, 30) + 12 xy(x - 1.5, y - 1.5)
        draw_disk(pos, 5, #FFF)
        
        const letter = player.board.tile[x][y].letter
        draw_text({
            pos: pos,
            font: history_font,
            color: #000,
            text: if letter == "Q" then "Qu" else letter})


// History
history_draw(player.history, xy(4, 60), SCREEN_SIZE.y - 30)

// Countdown
const time_left = max(end_time - utc_time, 0)
const timer_pos = xy(½ SCREEN_SIZE.x, SCREEN_SIZE.y - 10)
const α = 100% - time_left / (if game_type == SOLO then SOLO_INTERMISSION_TIME else GLOBAL_INTERMISSION_TIME)

draw_corner_rect(xy(0, timer_pos.y - 10), xy(SCREEN_SIZE.x, 19), #000, #FFF)
draw_corner_rect(xy(1, timer_pos.y - 9), xy(α * (SCREEN_SIZE.x - 2), 17), #0F0)

draw_text({
    font: score_font,
    text: format_number(time_left, "timer") + " until next game…",
    outline: #040,
    pos: timer_pos,
    color: #FFF})

if utc_time ≥ end_time:
    set_mode(Play) because "Timer"

