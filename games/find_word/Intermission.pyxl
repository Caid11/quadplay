Intermission
════════════════════════════════════════════════════════════════════════

todo("* Make SOLO version")
todo("Make most unique award (requires tracking uniqueness to show off the words)")
todo("Force GLOBAL to SOLO version when nobody else is there")


// Cycle through the award stages. See `STAGE`
let stage


/* `{avatar, score, word_list, representative_text}`
   `word_list` is Q-encoded */
const competitor_array = []

let player_competitor


// Competitors winning each award
let best_word_winner
let best_unique_winner
let longest_winner
let most_words_winner

let end_time

/* Words *not* found by the local player. Q-decoded. */
let unfound_word_array


/*
    if mode_frames mod 380 == 60:
        // Choose the next unfound word
        show_word_in_board(pop(unfound_word_array))
        */


/* Called from `draw_awards()` when `stage` == `STAGE.SUMMARY` */
def draw_award_summary()
& preserving_transform:
    draw_corner_rect(xy(-35, -36), xy(125, 63), player.avatar.color)
    avatar_draw_large(player.avatar, xy(-14, -6), false, #FFF)

    const shadow = 60% player.avatar.color
  
    const args = {font: history_font,
        x_align: "left",
        y_align: "baseline",
        shadow: shadow,
        color: #FFF}

    draw_text({…args, text: "Summary", pos: xy(31, -27), x_align: "center"})
    
    compose_transform(xy(55, 0))
    draw_text({ …args, text: format_number(player.score, "commas"), font: score_font, pos: xy(14, -5), x_align: "right"})
    draw_text({…args, text: "pts", pos: xy(18, -10)})

    const x = -46
    draw_text({…args, text: "Found", pos: xy(x, 5)})
    draw_text({…args, text: "" + size(player.history.list) + "/" + player.board.word_count, pos: xy(30, 5), x_align: "right"})
    
    if game_type == GLOBAL:
        draw_text({…args, text: "Unique", pos: xy(x, 14)})
        draw_text({…args, text: player_competitor.num_unique, pos: xy(30, 14), x_align: "right"})

    draw_text({…args, text: "Longest", pos: xy(x, 23)})
    draw_text({…args, text: player_competitor.longest_text, pos: xy(30, 23), x_align: "right"})



/* Draw and animate Awards (Summary, Longest, Best Word, Best Unique, High Score, Most Words) */
def draw_awards()
& preserving_transform:
    set_transform(xy(SCREEN_SIZE.x - 88, 34))

    if stage == STAGE.SUMMARY:
        draw_award_summary()
   
    else if stage == STAGE.BEST_WORD:
        draw_word_award("Best Word", best_word_winner)
   
    else if stage == STAGE.LONGEST:
        draw_word_award("Longest", longest_winner)
        
    else if stage == STAGE.BEST_UNIQUE:
        draw_word_award("Best Unique", best_unique_winner)
    
    else if stage == STAGE.MOST_WORDS:
        draw_most_words_award(most_words_winner)



/* Used for best_word, longest, The title is used to compute the field */
def draw_word_award(title, winner):
    const field = replace(lowercase(title), {" ": "_"})
    
    draw_corner_rect(xy(-35, -24), xy(69, 37), winner.avatar.color)

    draw_text({font: history_font, text: title + "!", color: player.board.selection_color, shadow: #000, pos: xy(0, -29), z: 2})
    draw_text({font: history_font, text: "→", color: player.board.selection_color, shadow: #000, pos: xy(32, -29), z: 2})

    avatar_draw_large(winner.avatar, xy(0, -5), false)
    show_word_in_board(winner[field + "_text"])
    board_draw_mini(player.board, xy(SCREEN_SIZE.x - 26, 36))



def draw_most_words_award(winner):
    ++draw_most_words_award.frames
    player.board.selection_color = #E1B

    draw_text({font: history_font, text: "Most Words: " + size(winner.word_list), color: player.board.selection_color, shadow: #000, pos: xy(0, -29), z: 2})
    draw_corner_rect(xy(-35, -24), xy(69, 37), winner.avatar.color)
    avatar_draw_large(winner.avatar, xy(0, -5), false, player.board.selection_color)

    const FRAMES_PER_WORD = 15
    show_word_in_board(array_value(winner.word_list, draw_most_words_award.frames / FRAMES_PER_WORD, "loop"))
    board_draw_mini(player.board, xy(SCREEN_SIZE.x - 26, 36))



/* word is Q-decoded */
def show_word_in_board(word):
    assert(word)
    if q_decode(board_selected_word(player.board)) ≠ word:
        board_deselect_all(player.board)
        player.board.selection = board_find_unencoded_word(player.board, word)
        player.board.selection_color = #E1B
        
        // Select these letters
        for index in player.board.selection:
            // Need +1 because this can be selected on frame 0
            player.board.tile[index.x][index.y].selected = mode_frames + 1
        


/* Draw the ranked competitors and perform UI logic */
def update_leaderboard()
& preserving_transform:
    set_clip(xy(0, 0), xy(SCREEN_SIZE.x, SCREEN_SIZE.y - 22))
    set_transform(xy(SCREEN_SIZE.x - 110, 72))

    const RANK_SPACING_Y = 16
    for competitor at i in competitor_array:
        const pos = xy(-3, i * RANK_SPACING_Y)
                
        const me = competitor == player_competitor

        // Highlight
        if me:
            draw_corner_rect(pos - xy(10, 9), xy(130, 18), player.avatar.color, ∅, ∅, -1)
            
        // Animate sprite
        let sprite = competitor.avatar.sprite
        if ⌊mode_frames / 30⌋ mod 2:
            sprite = sprite.spritesheet[sprite.tile_index.x][sprite.tile_index.y + 1]
         
        draw_sprite(sprite.x_flipped, pos)
        
        const shadow = if me then 60% competitor.avatar.color else ∅
        
        draw_text({
            text: competitor.avatar.name,
            pos: pos + xy(18, 0),
            shadow: shadow,
            color: if me then #FFF else competitor.avatar.color})
            
        draw_text({text: format_number(competitor.score, "commas"), pos: pos + xy(59, 0), x_align: "right", shadow: shadow, color: #FFF})
        draw_text({font: history_font, text: competitor.text, x_align: "right", pos: pos + xy(110, 0), shadow: shadow, color: #FFF})



def insert_synthetic_competitors(competitor_array, num_competitors):

    // Make the competitors stable in their personalities by using a fixed
    // rng.
    const rng = make_random(4581)
    
    for i < num_competitors:
        
        const sprite = avatar_sprite_from_linear_index(random_integer(0, AVATAR_SPRITE_COUNT - 1, rng))
        
        const competitor = {
            avatar: {
                sprite: sprite, 
                color: avatar_compute_color(sprite), 
                // Weigh the probability towards capital letters,
                // and always start with a capital letter
                name: random_value(ALPHABET, rng) + random_value(AVATAR_NAME_ALPHABET + ALPHABET, rng) + random_value(AVATAR_NAME_ALPHABET + ALPHABET, rng)},
            score: 0}
        
        // Make stable how good this player is overall, and then add noise per game
        const words_found = random_integer(5, 10) + random_integer(1, 20, rng)
        
        // Make a bogus word list for this competitor and score it.
        // Choose both from the player's discovered words and
        // from the board. Let collisions happen.
        
        const word_set = {}
        for i < 85% words_found:
            word_set[random_value(player.board.word_list)] = 1
        for i < 15% words_found:
            word_set[random_value(player.history.list).word] = 1
            
        competitor.word_list = keys(word_set)
                
        // Remove sensitive words from computer players
        iterate(competitor.word_list, remove_sensitive)
        
        sort(competitor.word_list, size_comparator)
        
        for word at i in competitor.word_list:
            competitor.score += score_word(word)
        
        push(competitor_array, competitor)



/* Convert the local player into a competitor */
def add_player_competitor():
    player_competitor = {
        avatar: player.avatar,
        score: player.score,
        word_list: []}
    
    for entry in player.history.list:
        push(player_competitor.word_list, entry.word)
        
    push(competitor_array, player_competitor)
    


def analyze_competitors(competitor_array):
    // How many players have each word; used for 
    // finding unique words
    const count = {}
    
    // Compute everyone's best results
    for competitor in competitor_array:
        
        // Censor names by slicing off the 2nd letter, if inappropriate,
        // and replacing common letter substitutions to prevent casual
        // looks-like thwarting
        if sensitive[lowercase(replace(competitor.avatar.name, LOOKS_LIKE))] or sensitive[lowercase(competitor.avatar.name)]:
            competitor.avatar.name = competitor.avatar.name[0] + competitor.avatar.name[2] + " "

        competitor.best_word_points = 0
        competitor.longest_size = 0
        for word in competitor.word_list:
            // Increment the count
            count[word] = (count[word] default 0) + 1
            
            const points = score_word(word)
            const text = q_decode(word)
            
            if (points > competitor.best_word_points) or (points == competitor.best_word_points and text > competitor.best_word_text):
                competitor.best_word_points = points
                competitor.best_word_text = text
                competitor.text = text
        
            if (size(text) > competitor.longest_size) or (size(text) == competitor.longest_size and text > competitor.longest_text):
                competitor.longest_size = size(text)
                competitor.longest_text = text
    
    // Find the best unique word for each competitor
    for competitor in competitor_array:
    
        competitor.num_unique = 0
        competitor.best_unique_points = 0
        competitor.best_unique_text = 0
    
        for word in competitor.word_list:
            if count[word] == 1:
                const points = score_word(word)
                const text = q_decode(word)
                
                // Nobody else has this word
                ++competitor.num_unique
                
                if points > competitor.best_unique_points or (points == competitor.best_unique_points and text > competitor.best_unique_text):
                    competitor.best_unique_points = points
                    competitor.best_unique_text = text
    
    // Update the history unique fields for the player competitor
    // as these are used for display. We don't need this for others
    for entry in player.history.list:
        if count[entry.word] == 1:
            entry.unique = true
    
    // Rank all competitors by score
    sort(competitor_array, "score", true)
        
    // Find the winner in each category. Ties are broken
    // by total score by running in order after that sort
    best_word_winner = competitor_array[0]
    best_unique_winner  = competitor_array[0]
    longest_winner = competitor_array[0]
    most_words_winner = competitor_array[0]
    
    for competitor in competitor_array:
        if competitor.best_word_points > best_word_winner.best_word_points:
            best_word_winner = competitor
            
        if competitor.best_unique_points > best_unique_winner.best_unique_points:
            best_unique_winner = competitor

        if competitor.longest_size > longest_winner.longest_size:
            longest_winner = competitor

        if size(competitor.word_list) > size(most_words_winner.word_list):
            most_words_winner = competitor



enter
────────────────────────────────────────────────────────────────────────
set_background(#333)
board_deselect_all(player.board, player)
sort(player.history.list, "points", true)

draw_most_words_award.frames = 0

// Reset the scroll position because layout differs
// from the main game
player.history.scroll = 0

if game_type == GLOBAL:
    end_time = next_global_game_utc_start_time()


unfound_word_array = []
for word in player.board.word_list:
    // Do not use player.already_found
    if not sensitive[lowercase(word)] and not player.already_found[q_encode(word)]:
        push(unfound_word_array, word)


// Sort from shortest to longest to emphasize impressive words
sort(unfound_word_array, size_comparator)

// Now swap some of the other words towards the back so that
// the player also feels like they could have gotten these
if size(unfound_word_array) > 10:
    for i < 3:
        swap(unfound_word_array, random_integer(0, size(unfound_word_array) - 8), size(unfound_word_array) - 1 - random_integer(1, 6))


resize(competitor_array, 0)
add_player_competitor()

                    
todo("Use real players in a GLOBAL game")

// Make some bogus competitors for testing purposes
insert_synthetic_competitors(competitor_array, 15)

todo("Trim down when there are very many competitors, keeping the top 4, the bottom 4, and 3 around the player")

analyze_competitors(competitor_array)

stage = STAGE.SUMMARY


frame
────────────────────────────────────────────────────────────────────────

// Cycle through awards, giving equal time to each
if game_type == GLOBAL:
    stage = min(⌊size(STAGE) * mode_frames / (60 GLOBAL_INTERMISSION_TIME)⌋, size(STAGE) - 1)

// Separator bars
draw_corner_rect(xy(SCREEN_SIZE.x - 125, 0), xy(2, SCREEN_SIZE.y), #000, ∅, -1)
draw_corner_rect(xy(SCREEN_SIZE.x - 125, 61), xy(125, 2), #000, ∅, 20)

history_update(player.history, {corner: xy(1, 1), size: xy(SCREEN_SIZE.x - 120, SCREEN_SIZE.y - 22)})

draw_awards()

update_leaderboard()

            
// Button/timer
if game_type == SOLO:

    const pos = xy(½ SCREEN_SIZE.x, SCREEN_SIZE.y - 10)
    const size = xy(150, 17)
    draw_rect(pos - xy(0, 1), size, #0F0, #FFF)
    draw_text({
        font: score_font,
        text: "Start New Game",
        outline: #090,
        pos: pos,
        color: #FFF})
        
    if (any_button_press(gamepad_array[0]) or (touch.pressed_a and overlaps(touch.xy, {pos: pos, size: size}))) and mode_frames > 15:
        set_mode(GenerateBoard) because "Button press"
        
else:
    // Countdown
    const time_left = max(end_time - utc_time, 0)
    const timer_pos = xy(½ SCREEN_SIZE.x, SCREEN_SIZE.y - 10)
    const α = 100% - time_left / (if game_type == SOLO then SOLO_INTERMISSION_TIME else GLOBAL_INTERMISSION_TIME)
    
    draw_corner_rect(xy(0, timer_pos.y - 10), xy(SCREEN_SIZE.x, 19), #000, #FFF)
    draw_corner_rect(xy(1, timer_pos.y - 9), xy(α * (SCREEN_SIZE.x - 2), 17), #0F0)
    
    draw_text({
        font: score_font,
        text: format_number(time_left, "timer") + " until next game…",
        outline: #090,
        pos: timer_pos,
        color: #FFF})
    
    if utc_time ≥ end_time:
        set_mode(GenerateBoard) because "Global timer"

