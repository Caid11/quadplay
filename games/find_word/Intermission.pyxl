Intermission
════════════════════════════════════════════════════════════════════════

todo("* Make SOLO version")
todo("Force GLOBAL to SOLO version when nobody else is there")


/* `{avatar, score, word_list, representative_text}`
   `word_list` is Q-encoded */
const competitor_array = []

let end_time
let unfound_word
let unfound_word_array

def points_order(A, B):
    return B.points - A.points
    
    
def word_comparator(entry, word):
    return entry.word == word
        
    
def length_comparator(A, B):
    return size(A) - size(B)


def swap(array, i, j):
    const temp = array[i]
    array[i] = array[j]
    array[j] = temp


/* History of words found by the local player */
def update_history()
& preserving_transform:
    set_clip(xy(0,0), xy(SCREEN_SIZE.x - 120, SCREEN_SIZE.y)) 
    history_draw(player.history, xy(2, 1), SCREEN_SIZE.y - 22)



/* Draw and animates Awards (Longest, Best Word, Best Unique, High Score, Most Words) */
def update_awards()
& preserving_transform:
    todo("Start with summary")
    
    /*
    Summary:
    
    Score       1,0000
    Found       37/122
    Longest     FOOBAR
    
    */
    todo("Implement Best Word award")
    todo("Implement Longest award")
    todo("Implement Best Unique award")
    todo("Implement High Score award")
    todo("Implement Most Words award")    

    const avatar = player.avatar
    set_transform(xy(SCREEN_SIZE.x - 95, 34))
    
    draw_text({font: history_font, text: "Best Word", color: #FFF, shadow: #000, pos: xy(0, -29), z: 2})
    avatar_draw_large(avatar, xy(0, -4))    



/* Words shown on the mini board */
def update_mini_board()
& preserving_transform:
    set_transform(xy(SCREEN_SIZE.x - 32, 36))
    
    if mode_frames mod 420 == 100:
        // Choose the next unfound word
        unfound_word = pop(unfound_word_array)
        
        // Select this word
        board_deselect_all(player.board)
        player.board.selection = board_find_unencoded_word(player.board, unfound_word)
        player.board.selection_color = #E1B
        
        // Select these letters
        for index in player.board.selection:
            player.board.tile[index.x][index.y].selected = mode_frames
    
        
    for y < ROWS:
        for x < COLS:
            const tile = player.board.tile[x][y]
            tile.pos = 12 xy(x - 1.5, y - 1.5)
            
            draw_disk(tile.pos, 5, if tile.selected then player.board.selection_color else #FFF)
            
            draw_text({
                pos: tile.pos,
                font: history_font,
                color: if tile.selected then #FFF else #000,
                text: if tile.letter == "Q" then "Qu" else tile.letter})
    
    if size(player.board.selection) > 0:
        // Draw word
        draw_text({
            font: history_font,
            text: "\"" + unfound_word + "\"",
            pos: xy(0, -31),
            shadow: #000,
            color: player.board.selection_color})
            
        // Draw connectors
        for 1 ≤ i < size(player.board.selection):
            const prev = player.board.selection[i - 1]
            const curr = player.board.selection[i]
            draw_line(player.board.tile[prev.x][prev.y].pos, player.board.tile[curr.x][curr.y].pos, player.board.selection_color, -1, 2)
    
    todo("Put # found at end of history")
    /*
    draw_text({
        font: history_font,
        text: "" + size(player.history.list) + "/" + player.board.word_count + " found",
        pos: xy(0, 30),
        shadow: #000,
        color: #FFF})*/



/* Draw the ranked competitors and perform UI logic */
def update_competitor_list()
& preserving_transform:
    set_clip(xy(0, 0), xy(SCREEN_SIZE.x, SCREEN_SIZE.y - 22))
    set_transform(xy(SCREEN_SIZE.x - 110, 80))    

    const RANK_SPACING_Y = 16
    for competitor at i in competitor_array:
        const pos = xy(-3, i * RANK_SPACING_Y)
                
        // Highlight
        if competitor.me:
            draw_corner_rect(pos - xy(10, 9), xy(130, 18), #F3C6, ∅, ∅, -1)
            
        // Animate sprite
        let sprite = competitor.avatar.sprite
        if ⌊mode_frames / 30⌋ mod 2:
            sprite = sprite.spritesheet[sprite.tile_index.x][sprite.tile_index.y + 1]
         
        draw_sprite(sprite.x_flipped, pos)
        draw_text({text: competitor.avatar.name, pos: pos + xy(17, 0), color: competitor.avatar.color})
        draw_text({text: competitor.score, pos: pos + xy(58, 0), x_align: "right", color: #FFF})
        draw_text({font: history_font, text: competitor.text, x_align: "left", pos: pos + xy(68, 0), color: #FFF})



def insert_synthetic_competitors(competitor_array, num_competitors):

    // Make the competitors stable in their personalities by using a fixed
    // rng.
    const rng = make_random(4581)
    
    for i < num_competitors:
        
        const sprite = avatar_sprite_from_linear_index(random_integer(0, AVATAR_SPRITE_COUNT - 1, rng))
        
        const competitor = {
            avatar: {
                sprite: sprite, 
                color: avatar_compute_color(sprite), 
                name: random_value(ALPHABET, rng) + random_value(ALPHABET, rng) + random_value(AVATAR_NAME_ALPHABET, rng)},
            score: 0,
            best_word_text: "",
            best_word_points: 0,
            longest_word_text: "",
            longest_word_size: 0}
        
        // Make stable how good this player is overall, and then add noise per game
        const words_found = random_integer(5, 10) + random_integer(1, 20, rng)
        
        // Make a bogus word list for this competitor and score it.
        // Choose about half from the player's discovered words and half
        // from the board. Let collisions happen
        
        const word_set = {}
        for i < ½ words_found:
            word_set[random_value(player.board.word_list)] = 1
            word_set[random_value(player.history.list).word] = 1
            
        competitor.word_list = keys(word_set)
        
        iterate(competitor.word_list, remove_sensitive)
        
        for word at i in competitor.word_list:
            competitor.score += score_word(word)
        
        push(competitor_array, competitor)



enter
────────────────────────────────────────────────────────────────────────
set_background(#333)
board_deselect_all(player.board, player)
//debug_print(player.board.word_list)
sort(player.history.list, points_order)

if game_type == GLOBAL:
    end_time = next_global_game_utc_start_time()


unfound_word_array = []
for word in player.board.word_list:
    if not sensitive[lowercase(word)] and not contains(player.history.list, word, word_comparator):
        push(unfound_word_array, word)


// Sort from shortest to longest to emphasize impressive words
sort(unfound_word_array, length_comparator)

// Now swap some of the other words towards the back so that
// the player also feels like they could have gotten these
if size(unfound_word_array) > 10:
    for i < 3:
        swap(unfound_word_array, random_integer(0, size(unfound_word_array) - 8), size(unfound_word_array) - 1 - random_integer(1, 6))

board_deselect_all(player.board)

// Convert the local player into a competitor
resize(competitor_array, 0)
local:
    const competitor = {
        avatar: player.avatar,
        score: player.score,
        best_word_text: "",
        best_word_points: 0,
        longest_word_text: "",
        longest_word_size: 0,
        me: true,
        word_list: []}

    for entry in player.history.list:
        push(competitor.word_list, entry.word)
        
    push(competitor_array, competitor)

                    
todo("Use real players in a GLOBAL game")

// Make some bogus competitors for testing purposes
insert_synthetic_competitors(competitor_array, 15)

todo("Trim down when there are very many competitors, keeping the top 3, the bottom 3, and 3 around the player")


todo("Mark unique words in history")


// Compute everyone's best
for competitor in competitor_array:
    for word in competitor.word_list:
        const points = score_word(word)
        const text = q_decode(word)
        
        if (points > competitor.best_word_points) or (points == competitor.best_word_points and text > competitor.best_word_text):
            competitor.best_word_points = points
            competitor.best_word_text = text
            competitor.text = text
    
        if (size(text) > competitor.longest_word_size) or (size(text) == competitor.longest_word_size and text > competitor.longest_word_text):
            competitor.longest_word_size = size(text)
            competitor.longest_word_text = text


// Rank all competitors    
sort(competitor_array, "score", true)

    
frame
────────────────────────────────────────────────────────────────────────

update_history()

// Score
/*
draw_text({
    font: score_font,
    text: format_number(player.score, "commas") + " pts",
    outline: #000,
    shadow: #000,
    pos: xy(left * SCREEN_SIZE.x, 18),
    color: #FFF})
*/

// update_awards()

update_mini_board()

update_competitor_list()


            
// Button/timer
if game_type == SOLO:

    const pos = xy(½ SCREEN_SIZE.x, SCREEN_SIZE.y - 10)
    const size = xy(150, 17)
    draw_rect(pos - xy(0, 1), size, #0F0, #FFF)
    draw_text({
        font: score_font,
        text: "Start New Game",
        outline: #090,
        pos: pos,
        color: #FFF})
        
    if (any_button_press(gamepad_array[0]) or (touch.aa and overlaps(touch.xy, {pos: pos, size: size}))) and mode_frames > 15:
        set_mode(GenerateBoard) because "Button press"
        
else:
    // Countdown
    const time_left = max(end_time - utc_time, 0)
    const timer_pos = xy(½ SCREEN_SIZE.x, SCREEN_SIZE.y - 10)
    const α = 100% - time_left / (if game_type == SOLO then SOLO_INTERMISSION_TIME else GLOBAL_INTERMISSION_TIME)
    
    draw_corner_rect(xy(0, timer_pos.y - 10), xy(SCREEN_SIZE.x, 19), #000, #FFF)
    draw_corner_rect(xy(1, timer_pos.y - 9), xy(α * (SCREEN_SIZE.x - 2), 17), #0F0)
    
    draw_text({
        font: score_font,
        text: format_number(time_left, "timer") + " until next game…",
        outline: #090,
        pos: timer_pos,
        color: #FFF})
    
    if utc_time ≥ end_time:
        set_mode(GenerateBoard) because "Global timer"

