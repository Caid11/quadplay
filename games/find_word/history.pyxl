
/* List of words found by a `player`. */
def make_history():
    return {
        // Each entry is `{text, word, tiles, points, color, emphasize_frame, pos}`.
        // `pos` is computed as a side effect of draw history
        // `word` is Q-encoded, `text` may contain arbitrary characters
        list: [],
        
        /* 
          `[{text, word, points}, …]`. Recomputed by `update_free_row_list()`
          in the `freePhase` mode.
            
         `size(last_value().word)` is the number of tiles used in a word.
         `color_for_points(last_value().points)` is the color to use.
        */
        free: [],
        
        // Auto computed and overriden on new word spawn or resize,
        // but can be manually affected by the player
        scroll: 0,

        // Scroll computation resets when screen size changes.
        // This was the size it was computed for.
        scroll_screen_size: xy(0, 0),
        
        // Scroll computation resets when the list size changes.
        // This was the size it was computed for.
        scroll_history_size: 0,
        
        // Due to finger on history
        drag_start: {
            // Position at which the current drag started,
            // ∅ if not in a drag
            pos: ∅,
            
            // history.scroll when the drag started
            scroll: ∅
        }
    }


    
/* True if A and B have the same value for their `word` property.
   Useful for comparing two history list entries. */
def word_property_equals(A, B):
    return A.word == B.word



/* Mutates `pos`, returns `max_width`. Called from `history_update()`. */
def history_draw(history, pos, max_height):
    todo("Visualize history scroll state on Play view")
    todo("Vertical scroll history")
    
    const start_y = pos.y
    
    let max_width = 0
    
    def history_draw_entry(entry):
        // Wrap into multiple columns if this element will
        // go off the page. Do this here so that we never
        // reset right before the end
        if pos.y > max_height - 8:
            pos.y = start_y
            pos.x += max_width + HISTORY_COLUMN_SEPARATION
            max_width = 0
            
        const emphasize = max(0, entry.emphasize_frame - game_frames)
        
        const wiggle = xy(oscillate(18% emphasize, -1, +1) - sign(emphasize), 0)
    
        // Save for animation later
        entry.pos = transform_ws_to_ss(pos)
        
        // Hide while animation is playing for this word, but
        // draw invisibly so we get bounds
        const show = game_frames > entry.reveal_frame
        const color = entry.color
        const outline = if emphasize then #FFF else entry.outline
        
        let text = entry.text
        
        // Emphasize rare values when on the Intermission mode.
        // For other modes (e.g., Play), `rare` will never be true.
        if entry.rare: text += "★"
        
        const flash = entry.rare and (game_frames + 500 - ¼ pos.y) mod 360 > 345
            
        const bounds = draw_text({
            // Bounce if emphasized
            pos: pos + wiggle,
            font: if emphasize then history_emphasis_font else history_font,
            x_align: "left",
            y_align: "top",
            color: if show then (if flash then #fff else color) else #0000,
            outline: if show then outline else #0000,
            z: emphasize,
            text: text})

        // Track if this makes the column larger
        max_width = max(max_width, text_width(history_font, text))
        pos.y += history_font.line_height + 1

    if not player.has_achievement["Make Second Word"]:
        const text = (
            if player.has_achievement["Make First Word"] 
            then "Great! Keep going until the timer expires." 
            else (
                if player.using_gamepad
                then replace("Select a chain of letters with (a) to spell a word", joy.prompt)
                else "Swipe through a chain of letters to spell a word"))
            
        draw_text({
            // Bounce if emphasized
            pos: pos + xy(0, 10),
            font: score_font,
            x_align: "left",
            y_align: "top",
            color: #FFF,
            outline: #000,
            z: 100,
            wrap_width: 150,
            text: text})

    if get_mode() ≠ GlobalIntermission:
        // Regular list first
        for entry in history.list:
            history_draw_entry(entry)
        // Separator
        if size(history.list) and size(history.free):
            history_draw_entry({text: "", color: #888, reveal_frame: 0, emphasize_frame: 0})
            
    if size(history.free):        
        // free list
        for entry in history.free:
            history_draw_entry(entry)
    
    if get_mode() == GlobalIntermission:
        // Separator
        if size(history.list) and size(history.free):
            history_draw_entry({text: "", color: #888, reveal_frame: 0, emphasize_frame: 0})
            
        // Regular list second
        for entry in history.list:
            history_draw_entry(entry)
    
    return max_width
   
    

/* Adds to `history[list_name]`. Returns the color to use for the selection. */
def history_add(history, list_name, word, points):
    assert(word)
    assert(type(word) == "string")
    
    player_achieve(player, "Make First Word")
    if size(history.list) == 2:
        player_achieve(player, "Make Second Word")
    
    let color = color_for_points(points)
    
    let text_color = color
    let outline = ∅
    
    // Super scorer colors
    if points ≥ 65:
        outline = lerp(color, #FFF, 40%)
        text_color = #FFF
    else if points ≥ 45:
        outline = color
        text_color = #FFF
    else if points ≥ 35:
        outline = lerp(color, #000, 25%)
        text_color = lerp(color, #FFF, 50%)
    
    // Put free words in quotes to clarify that they
    // were not found during the regular game
    let text = q_decode(word)
    if list_name == "free":
        text = "«" + text + "»"
        
    push(history[list_name], {
        text:    text + " " + points, 
        word:    word,
        emphasize_frame: 0,
        reveal_frame: game_frames + POINTS_ANIMATION_FRAMES,
        points:  points, 
        color:   text_color,
        outline: outline})
    
    return color
    
    

/* Draw the word history and manage touch dragging */
def history_update(history, history_rect)
& with drag_start, scroll_screen_size, scroll_history_size in history
& preserving_transform:

    set_clip(history_rect)
    
    if not equivalent(SCREEN_SIZE, scroll_screen_size):
        // Reset on window change
        history.scroll = 0

    const pos = xy(3, 2)
    let max_width
    
    preserving_transform:
        set_transform(history_rect.corner - xy(history.scroll, 0))
        max_width = history_draw(history, pos, history_rect.size.y)

    if (player.has_ability["Know Word Count"] or in_waiting_room):
        draw_text({
            pos: history_rect.corner + history_rect.size - xy(2, 1),
            font: history_font,
            text: "Found " + size(history.list) + "/" + player.board.word_count,
            color: #DDD,
            outline: get_background(),
            x_align: "right",
            y_align: "bottom"})

    const overflow = pos.x + max_width - history_rect.size.x + 1

    if not drag_start.pos:
        // Start drag
        if touch.pressed_a and overlaps(touch.xy, history_rect):
            drag_start.pos = xy(touch.xy)
            drag_start.scroll = history.scroll
    else if touch.a:
        // Continue drag
        history.scroll = clamp(drag_start.scroll + drag_start.pos.x - touch.x, 0, overflow)
    else:
        // End drag
        drag_start.pos = ∅
    
    const history_size = size(history.list) + size(history.free)
    
    if not drag_start.pos and (not equivalent(SCREEN_SIZE, scroll_screen_size) or scroll_history_size ≠ history_size):
        scroll_screen_size = xy(SCREEN_SIZE)
        scroll_history_size = history_size
        // Set the scroll to whatever it needs to be to keep the 
        // most recent words on screen
        history.scroll = max(history.scroll, overflow)
    
    if overflow < 0:
        history.scroll = 0
        


/* Gets the history rect in `Play` and `FreeMode` modes. */
def get_history_rect():
    const board_pos = get_board_pos()
    const board_size = get_board_pixel_size()

    if landscape():
        return {
            corner: xy(1, 1), 
            size: xy(
                board_pos.x - ½ board_size.x - ¼ TILE_EXTENT + 1, 
                SCREEN_SIZE.y - (if player.has_ability["Free Mode"] and not in_waiting_room then 42 else 8))}
    else:
        // Portrait
        return {
            corner: xy(1, 1),
            size: xy(SCREEN_SIZE.x - 2, board_pos.y - ½ board_size.y - 32)}


        