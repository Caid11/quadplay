Play
════════════════════════════════════════════════════════════════════════
def enter_free_mode():
    board_deselect_all(player.board, player)
    push_mode(FreeMode) because "Button"

def enter_auto_mode():
    board_deselect_all(player.board, player)
    push_mode(AutoMode) because "Button"


enter
────────────────────────────────────────────────────────────────────────
assert(not in_waiting_room)

play_sound(start_sound)
    
last_countdown_sound_time = now()
start_time = frame_utc_now

// Compute end_time
if game_type == SOLO:
    end_time = frame_utc_now + SOLO_GAME_TIME
else:
    assert(game_type == GLOBAL)
    
    end_time = prev_global_game_utc_start_time() + GLOBAL_GAME_TIME

    assert(
        end_time > frame_utc_now + GLOBAL_JOIN_MIN_REMAINING_TIME - 1 or 
        DEBUG.INTERMISSION,
        "The game should not end so soon")

set_background(
    if game_type == GLOBAL 
    then GLOBAL_BACKGROUND_COLOR
    else SOLO_BACKGROUND_COLOR)

// Started more than 10s late, do not affect
// ratio stats
joined_late = (end_time - start_time < GLOBAL_GAME_TIME - 10)

board_deselect_all(player.board, player)



frame
────────────────────────────────────────────────────────────────────────
const time_left = end_time - frame_utc_now   

// Disallow rotation if the mode is about to end
const allow_rotate = (60 time_left) > (90° / ROTATION_SPEED)

player_update(player, ∅, allow_rotate)

if player.has_ability["Free Mode"]:        
    handle_ability_button(0, "Free", "Free", ability_icon.free_mode, "(q)", enter_free_mode)

if player.has_ability["Auto 2x2"]:
    handle_ability_button(1, "Auto", "Auto", ability_icon.auto_mode, "(d)", enter_auto_mode)
    

if time_left ≤ 20/60:
    // Make a few frames black at the end so that a player can
    // still trace a little further but can't see. This makes
    // it feel like they squeezed in one more word and weren't
    // "robbed" if in the process of selecting. Without this
    // it always feels like "I was just about to finish my word"
    draw_corner_rect(xy(0, 0), SCREEN_SIZE, #000, ∅, 100)
    
    
if time_left ≤ 0 or DEBUG.INTERMISSION:
    board_deselect_all(player.board, player)
    if game_type == SOLO:
        set_mode(SoloIntermission) because "SOLO and timer"
    else:
        set_mode(GatherGlobalResults) because "GLOBAL and timer"


// Hint for compiler:
// push_mode(Rotate) because "Rotate button"


leave
────────────────────────────────────────────────────────────────────────
play_sound(times_up_sound)
if game_type == GLOBAL:
    player_achieve(player, "Play Global Match")
    

// Accumulate the free mode points into the score
// now that they're locked in
for points in entry in player.history.free:       
    player.score += points

// Reset the scroll position because layout differs
// from the main game during intermission
player.history.scroll = 0

// Sort words by final score
sort(player.history.list, "points", true)
sort(player.history.free, "points", true)
