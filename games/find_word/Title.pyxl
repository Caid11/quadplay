Title
════════════════════════════════════════════════════════════════════════

const INTRO_PRE_FRAMES = 9
const INTRO_BEAT_FRAMES = 40
const INTRO_NUM_BEATS = 6
const INTRO_DURATION = INTRO_PRE_FRAMES + INTRO_BEAT_FRAMES * INTRO_NUM_BEATS

const SLIDE_FRAMES = 40
const HIGHLIGHT_COLOR = #F3C

const fake_player = make_player()

let selected_index = 0

/* Hook for the intro sequence. If ∅ the intro is over */
let intro = ∅

/* Array of strings for background by row */
const background_word_array = []


def update_button(pos, text, index):
    const selected = selected_index == index
    
    const BUTTON_SIZE = xy(132, 24)
    const SELECTED_BUTTON_COLOR = CURSOR_COLOR
    
    if selected:
        // Drop shadow
        draw_rect(pos + xy(0, 4), BUTTON_SIZE + 6, #0004, ∅, ∅, 100)
        
        // Highlight
        for 1 ≤ i < 4: 
            draw_rect(pos, BUTTON_SIZE + 2 i, ∅, rgba(lerp(#FFF, SELECTED_BUTTON_COLOR, (i + 1) / 4), 50%), ∅, 100)
        draw_rect(pos, BUTTON_SIZE, SELECTED_BUTTON_COLOR, #FFF, ∅, 100)
        
    else:
        // Drop shadow
        draw_rect(pos + xy(0, 2), BUTTON_SIZE, #0003, ∅, ∅, 100)
        
        // Background
        draw_rect(pos, BUTTON_SIZE, #FFFD, #666, ∅, 100)
        
    draw_text({
        text: text, 
        font: score_font,
        pos: pos + xy(0, 1),
        color: if selected then #FFF else #000,
        outline: if selected then #090 else ∅,
        z: 101})
    
    const rect = {pos: pos, size: BUTTON_SIZE}
    if touch.hover and overlaps(touch.hover, rect):
        selected_index = index
    
    
    if (not intro and
        mode_frames > 2 and 
        ((touch.aa and overlaps(touch.xy, rect)) or
         (selected and gamepad_array[0].aa))):
        game_type = index
        
        // When did the previous game start?
        const prev_start = prev_global_game_utc_start_time()
        
        // Did the previous game finish (i.e., there is no current game)
        const prev_game_finished = utc_time ≥ prev_start + GLOBAL_GAME_TIME
                
        // Is the next game about to begin? If they are within 2 seconds of the next
        // game just send them to the game a little early, it isn't a huge
        // advantage and avoids any race condition
        const next_game_imminent = utc_time > prev_start + GLOBAL_PERIOD - 2
        
        // How much time is left in the current game?
        const curr_game_remaining_time = max((prev_start + GLOBAL_GAME_TIME) - utc_time, 0)

        /*        
        debug_print(
            "prev_start =", prev_start,
            "\nprev_game_finished =", prev_game_finished,
            "\nnext_game_imminent =", next_game_imminent,
            "\ncurr_game_remaining_time =", curr_game_remaining_time) */
        
        if ((index == GLOBAL and
            (prev_game_finished or curr_game_remaining_time < GLOBAL_JOIN_MIN_REMAINING_TIME) and
            not next_game_imminent) or DEBUG_WAITING_ROOM):
            // There is no game currently running because the global game is in 
            // the GameOver state, or about to be so. Send this player to the waiting room
            // so that they aren't bored. 
            set_mode(WaitingRoom) because "No global in progress"
        else:
            set_mode(Play) because "Selected"
        


def bounce_row(y, sound default select_tile_sound):
    play_sound(sound)
    board_deselect_all(fake_player.board, fake_player)
    for x < 4:
        push(fake_player.board.selection, xy(x, y))
        fake_player.board.tile[x][y].selected = mode_frames


def bounce_row1(): bounce_row(0)

def bounce_row2(): bounce_row(1)

def bounce_row3(): bounce_row(2)

def bounce_row4(): bounce_row(3)

def highlight_random_row():
    fake_player.board.selection_color = HIGHLIGHT_COLOR
    bounce_row(random_integer(0, ROWS - 1), word_sound)
    
def intro_cleanup():
    intro = ∅ 
    
def ease_out(f):
    return sign(f) * pow(abs(f), 1.3)

/* Jump to the end of the intro */
def skip_intro():
    highlight_random_row()
    remove_frame_hook(intro)
    intro = ∅


// Initialize the board
const name = ["FIND", "WORD", "ALLL", "NITE"]
for x < COLS:
    for y < ROWS:
        fake_player.board.tile[x][y].letter = name[y][x]



set_random_seed()

// Initialize the background words
for y < 20:
    let s = random_safe_word()
    while size(s) < 250:
        s += " " + random_safe_word()
    background_word_array[y] = s

/*
let A = make_random(11676561)
let B = make_random(11676562)
for i < 100:
    debug_print(random_integer(0, 99, A), random_integer(0, 99, B))
*/

enter
────────────────────────────────────────────────────────────────────────
set_background(#000)
set_hooks()

fake_player.board.selection_color = TILE_CENTER_SELECTED_COLOR
board_deselect_all(fake_player.board, fake_player)


intro = sequence(
    INTRO_PRE_FRAMES, 
    bounce_row1, INTRO_BEAT_FRAMES,
    bounce_row2, INTRO_BEAT_FRAMES,
    bounce_row3, INTRO_BEAT_FRAMES,
    bounce_row4, INTRO_BEAT_FRAMES,
    highlight_random_row,
    SLIDE_FRAMES + 100,
    intro_cleanup)


frame
────────────────────────────────────────────────────────────────────────
draw_text({
        pos: xy(0, 0),
        font: tile_point_font,
        text: "v" + CREDITS.version,
        color: #777,
        y_align: "top",
        x_align: "left",
        z: 1})

for s at y in background_word_array:
    draw_text({
        font: tile_font,
        color: #333,
        text: s,
        pos: xy(sign((y mod 2) - 0.5) * 0.2 oscillate(mode_frames, -2000, 2000) - 700, 22 y),
        x_align: "left",
        z: -2})

// Spin after the intro
const θ = -0.2° max(0, mode_frames - INTRO_DURATION)
const pos = ½ SCREEN_SIZE
player_update_board(fake_player, pos, θ, false)
draw_rect(pos, board_pixel_size() + 22, fake_player.board.selection_color, ∅, θ, -1) 

// How far to slide the buttons, 0 if the intro has been skipped
const slide = if intro then (3 min(ease_out(mode_frames - INTRO_DURATION - SLIDE_FRAMES), 0)) else 0

update_button(pos - xy(slide, 30), "SOLO", 0)
update_button(pos + xy(slide, 30), "GLOBAL", 1)

if gamepad_array[0].xx or gamepad_array[0].yy:
    if intro: skip_intro()
    // Change selection
    selected_index = loop(selected_index + 1, 2)

if any_button_press() or touch.aa:
    skip_intro()

