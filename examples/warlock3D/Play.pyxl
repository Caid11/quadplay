Play
════════════════════════════════════════════════════════════════════════

def draw_controls(control_scheme, gamepad, gamepad2) preserving_transform:
    set_transform(xy(28, SCREEN_SIZE.y - 19), xy(1, 1), 200)
    const TEXT_COLOR = #DBBC
    
    draw_text(font, control_scheme + "\n" + gamepad.prompt["(q)"] + " to Change", xy(0, -24), TEXT_COLOR, ∅, ∅, "center", "bottom")
    
    draw_sprite(shapes_sprite.arrow.rotated_90, xy(0, -6), ∅, 30%)
    draw_text(font, gamepad.prompt["[^]"], xy(0, -12), TEXT_COLOR, ∅, ∅, "center", "bottom")

    const turn_right = if control_scheme == "D-PAD" then gamepad.prompt["[>]"] else (if control_scheme == "MOUSE" then "Mouse" else gamepad2.prompt["[>]"])
    draw_sprite(shapes_sprite.curved_arrow, xy(12, -6), ∅, 30%)
    draw_text(font, turn_right, xy(9, -12), TEXT_COLOR, ∅, ∅, "left", "bottom")
    
    const turn_left = if control_scheme == "D-PAD" then gamepad.prompt["[<]"] else  (if control_scheme == "MOUSE" then "Mouse" else gamepad2.prompt["[<]"])
    draw_sprite(shapes_sprite.curved_arrow.x_flipped, xy(-12, -6), ∅, 30%)
    draw_text(font, turn_left, xy(-10, -12), TEXT_COLOR, ∅, ∅, "right", "bottom")
    
    const strafe_left = gamepad.prompt[if control_scheme == "D-PAD" then "(e)" else "[<]"]
    draw_sprite(shapes_sprite.arrow.rotated_180, xy(-12, 6), ∅, 30%)
    draw_text(font, strafe_left, xy(-9, 11), TEXT_COLOR, ∅, ∅, "right", "top")
    
    const strafe_right = gamepad.prompt[if control_scheme == "D-PAD" then "(f)" else "[>]"]
    draw_sprite(shapes_sprite.arrow, xy(12, 6), ∅, 30%)
    draw_text(font, strafe_right, xy(8, 11), TEXT_COLOR, ∅, ∅, "left", "top")

    draw_sprite(shapes_sprite.arrow.rotated_270, xy(0, 6), ∅, 30%)
    draw_text(font, gamepad.prompt["[v]"], xy(0, 11), TEXT_COLOR, ∅, ∅, "center", "top")
    
    draw_text({font:font, text:replace("{color: #FFF Jump}{br}(a)", gamepad.prompt), color:TEXT_COLOR, x_align: "center", y_align: "center", pos:xy(40, 11), markup: true})


// Moves the entity.pos along entity.vel, sliding it along
// the nonempty sprites in map[layer].
def entity_slide_move_map(entity, map, layer) preserving_transform:
    // Map cells have integer coordinates at their centers
    const half_cell = ½ map.sprite_size

    // Bounds on everywhere the entity could be in map coordinates.
    // Because integers are map cell centers
    const map_lo = ⌊transform_ws_to_map_space(map, entity.pos - ½ entity.size + min(entity.vel, xy(0, 0)))⌋
    const map_hi = ⌊transform_ws_to_map_space(map, entity.pos + ½ entity.size + max(entity.vel, xy(0, 0)))⌋

    // The mathematically elegant way to solve this problem is to 
    // sweep the disk through collision with all nearby edges in
    // the map. To perform the swept disk, convert each edge into a
    // capsule and collide a ray with it. The capsule itself is in
    // turn two disks with an oriented line segment between them
    // (since the other side of the capsule cannot be hit).
    //
    // However, for the specific case of walls that are only axis
    // aligned and small velocities, we can simply test moving in each
    // axis independently and collide with walls as if they were entities    


    // Debug visualization on the minimap   
    if false:
        const corner = xy(10, 1)
        const extent = xy(36, 36)
        set_transform(corner + ½ extent, xy(1, 1))
        set_camera({pos: xz_to_xy(view.pos), angle: 180° + view.yaw, zoom: ¼})

    
    // Every tile that we could possibly hit
    const wall_array = []
    for map_lo.x ≤ map_x ≤ map_hi.x:
        for map_lo.y ≤ map_y ≤ map_hi.y:
            if map.layer[layer][map_x][map_y]:
                // Create an entity at the location of this wall
                
                // Integer map coords are at the corners, so place
                // the wall entity centered by offsetting the map coord
                const wall = {
                    shape: "rect",
                    size: map.sprite_size,
                    scale: xy(1, 1),
                    pivot: xy(0, 0),
                    angle: 0°,
                    pos: transform_map_space_to_ws(map, xy(map_x, map_y) + ½)
                }

                // Debug visualization on the minimap   
                if false:
                    draw_sprite(map.layer[layer][map_x][map_y], wall.pos, ∅, ∅, ∅, 300, #F00C)
        
                // Ignore this wall if it is already creating
                // a collision and velocity is trying to move away 
                // from it so that we can escape
                if dot(wall.pos - entity.pos, entity.vel) ≤ 0 or not overlaps(wall, entity):
                    push(wall_array, wall)


    if size(wall_array) == 0:
        // Nothing to hit (a common case)
        entity.pos += entity.vel
        return
    
    // If we expected large velocities
    // compared to the size of the map cells, then
    // we would alternate between axes in smaller steps
    // and on failure would binary search for the largest
    // successful step. Given that this game example moves
    // slowly compared to the sizes, we just take one large
    // step
    for axis in "xy":
        const old = entity.pos[axis]
        entity.pos[axis] += entity.vel[axis]
        for wall in wall_array:
            if overlaps(entity, wall):
                // Fail! Undo. 
                entity.pos[axis] = old
                break

        
def threshold(src, threshold):
    if is_number(src):
        return if |src| > threshold then (src - threshold) / (100% - threshold) else 0
        
    const dst = {}
    for val at key in src:
        dst[key] = if |val| > threshold then (val - threshold) / (100% - threshold) else 0
    return dst
    

def simulate_view(view, gamepad, gamepad2):
    if gamepad.qq: 
        if view.control_scheme == "D-PAD":
            view.control_scheme = "DUAL D-PAD"
        else if view.control_scheme == "DUAL D-PAD":
            view.control_scheme = "DUAL ANALOG"
        else if view.control_scheme == "DUAL ANALOG":
            view.control_scheme = "MOUSE"
            device_control("set_mouse_lock", true)
        else: // MOUSE
            device_control("set_mouse_lock", false)
            view.control_scheme = "D-PAD"

    // Rotation
    let rotate = xy(gamepad.x, 0)
    if view.control_scheme == "DUAL D-PAD":
        rotate = gamepad2.xy
    else if view.control_scheme == "MOUSE":
        // 75% is mouse sensitivity
        rotate = 75% device_control("get_mouse_state").dxy
    else if view.control_scheme == "DUAL ANALOG":
        rotate = threshold(device_control("get_analog_axes", 0, 1), 15%)
    
    
    // No hysteresis on mouse for sharper control
    view.spin = lerp(view.spin, -1.6° rotate, if view.control_scheme == "MOUSE" then 100% else 25%)
    view.pitch = clamp(view.pitch + view.spin.y, -30°, +30°)
    view.yaw += view.spin.x
    
    const MAX_SPEED      = 1.8
    const STRAFE_SPEED   = 80% MAX_SPEED
    const FORWARD_SPEED  = MAX_SPEED
    const BACKWARD_SPEED = 60% MAX_SPEED
        
    // x = strafe, -z = forward
    let strafe = gamepad.x
    let walk = -gamepad.y
    if view.control_scheme == "D-PAD":
        strafe = (gamepad.f - gamepad.e)
    else if view.control_scheme == "DUAL ANALOG":
        const stick = threshold(device_control("get_analog_axes", 0, 0), 20%)
        strafe = stick.x
        walk = -stick.y
    
    let desired_vs_vel = xz(STRAFE_SPEED * strafe, walk * (if walk < 0 then FORWARD_SPEED else BACKWARD_SPEED))
    
    desired_vs_vel = direction(desired_vs_vel) * min(‖desired_vs_vel‖, MAX_SPEED)
    
    // Adjust [view space] desired speed smoothly
    view.speed = lerp(view.speed, desired_vs_vel, 20%)  

    const fwd = xz_to_xy(ws_forward(view))
    
    // Make a temporary 2D entity to use the slide move helper
    const proxy = {
        size: xy(2 view.radius, 2 view.radius),
        shape: "disk",
        pos: xz_to_xy(view.pos),
        pivot: xy(0, 0),
        angle: 0°,
        scale: xy(1, 1),
        vel: fwd * -view.speed.z + perp(fwd) * view.speed.x,
    }
    
    const old_pos = xyz(view.pos)
    entity_slide_move_map(proxy, dungeon_map, WALL_LAYER)
    
    view.pos.x = proxy.pos.x; view.pos.z = proxy.pos.y
    
    if view.pos.y ≤ 32 and view.jump_vel ≤ 0:
        view.pos.y = 32
        view.jump_vel = 0
        if gamepad.aa: view.jump_vel = +2
        const move = ‖xz(old_pos - view.pos)‖
        if move > 0.5:
            if not walk_audio:
                walk_audio = play_sound(loop_footsteps_sound, true, 200%)
            set_playback_rate(walk_audio, max(2.8 move / MAX_SPEED, 100%))
        else:
            stop_audio(walk_audio)
            walk_audio = ∅
    else:
        stop_audio(walk_audio)
        walk_audio = ∅
        view.pos.y = max(32, view.pos.y + view.jump_vel)
        view.jump_vel -= 0.1
           

const view = make_view(dungeon_map)

const billboard_pos = xyz(view.pos.x, 28, view.pos.z - 64)

// Holds the walk loop when playing
let walk_audio = ∅

enter
────────────────────────────────────────────────────────────────────────

play_sound(loop_castle_sound, true, 30%)


frame
────────────────────────────────────────────────────────────────────────

simulate_view(view, gamepad_array[0], gamepad_array[1])
set_transform(½ SCREEN_SIZE + xy(0, -view.pitch * 2/1°))

draw_floor_and_ceiling(view, dungeon_map)
draw_walls(view, dungeon_map)
draw_billboard(view, allagon_sprite[0][0], billboard_pos)

draw_minimap(view, dungeon_map)
draw_controls(view.control_scheme, gamepad_array[0], gamepad_array[1])

