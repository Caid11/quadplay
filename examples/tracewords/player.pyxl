def make_player():
    return {
        board: make_board(),
        
        score: 0,
        
        gamepad: gamepad_array[0],
        
        // Q-encoded upper case words that have already been found
        already_found: {},
        
        // Each entry is {label, tiles, points, color}.
        // Used for display.
        history: [],
        
        // Determined by most recent input method.
        // Show button prompts and cursor when using gamepad
        using_gamepad: false,
        
        // {word, score} sorted by score
        word_array: []}
        


def _update_rotate_button(board_pos):
    let rotate_button_sprite = shapes.curved_arrow.rotated_270
    
    let rotate_button_pos = board_pos + xy(-4, -19) + xy(½, -½) board_pixel_size()
        
    draw_disk(rotate_button_pos, 10, ∅, #FFF)
    draw_sprite(rotate_button_sprite, rotate_button_pos + xy(1, 0), ∅, 50%)
    if player.using_gamepad:
        draw_text({font: tile_point_font, text: joy.prompt["(b)"], x_align: "right", pos: rotate_button_pos + xy(-6, 7), color: #FFF, outline: #000})

    if (touch.aa and overlaps({pos: rotate_button_pos, size: rotate_button_sprite.size}, touch.xy)) or joy.bb:
        push_mode(Rotate) because "Rotate button"


        
def _player_draw_score(player, board_pos):
    let score_pos = board_pos + xy(+½, -½) * board_pixel_size() - xy(40, 19)
        
    draw_text({
        pos: score_pos,
        font: font,
        text: format_number(player.score, "commas") + " pts",
        color: #FFF,
        y_align: "center",
        x_align: "right"})



/* Submits `word` and all of its prefixes (but not other substrings)
   for scoring. The `word` is Q-encoded. */
def player_submit_word(player, word):
    
    let note = ""
    for i ≤ size(word) - MIN_WORD_LENGTH:
        // Submit in reverse order from what was actually entered
        const subword = slice(word, 0, size(word) - i)
        
        const points = score_word(subword)
        if points > 0 and not player.already_found[subword]:
            player.already_found[subword] = true
            
            push(player.history, {
                label: note + q_decode(subword), 
                tiles: size(subword), 
                points: points, 
                color: color_for_points(points)})
                
            player.score += points

            // Mark subsequent words so that it is clear what
            // was actually submitted
            note = "+"
        


/* Run UI for this player and draw their board */
def player_update(player, angle default 0°, allow_selection default false):
    // Track most recent UI method
    if touch.pressed_a:
        player.using_gamepad = false
    else if player.gamepad.aa or player.gamepad.bb or player.gamepad.dx or player.gamepad.dy:
        player.using_gamepad = true
        
    
    if touch.released_a:
        todo("Release animation and sound")
        player_submit_word(player, board_selected_word(player.board))

    // Version/debugging
    draw_text({
        pos: xy(5, 5),
        font: tile_point_font,
        text: "Playing board \"" + player.board.seed + "\" on v" + CREDITS.version,
        color: #999,
        y_align: "top",
        x_align: "left",
        z: -1})

    let board_pos;
    
    // Our board has some content at the top, so don't switch
    // to portrait until all of the UI will be visible
    if landscape():
        // Landscape. Put at the bottom right (feel "closer" to a right handed mouse player)
        // Leave some space on the right so that if someone has the bad idea to play on a phone in this orientation
        // they won't be jammed against the edge with their thumb.
        board_pos = xy(SCREEN_SIZE.x - ½ board_pixel_size().x - 16, ½ SCREEN_SIZE.y + 12)
    else:
        // Portrait. Put at the bottom, centered, unless the screen is not very high
        board_pos = xy(½ SCREEN_SIZE.x, SCREEN_SIZE.y - ½ board_pixel_size().y - 18)
        
        // Slide up a little on narrow screens so that it is easier to swipe on a phone
        board_pos.y -= ⅓ max(SCREEN_SIZE.y - (board_pixel_size().y + 60), 0)
        
    board_update(player.board, board_pos, angle, player.already_found, allow_selection)

    _player_draw_score(player, board_pos)
    
    if allow_selection:
        _update_rotate_button(board_pos)
        
    _player_draw_history(player, board_pos)



def landscape():
    return SCREEN_SIZE.x + 28 > SCREEN_SIZE.y


def _player_draw_history(player, board_pos)
& preserving_transform:
    
    let list_rect
    if landscape():
        list_rect = {corner: xy(0, 22), size: xy(board_pos.x - ½ board_pixel_size().x - ¼ TILE_EXTENT, SCREEN_SIZE.y - 23)}
    else:
        list_rect = {corner: xy(0, 0), size: xy(SCREEN_SIZE.x, board_pos.y - ½ board_pixel_size().y - 32)}
    
    todo("Set clip")
    set_transform(list_rect.corner)
    
    let pos = xy(0, 0)
    let max_width = 0
    for entry in player.history:
        const bounds = draw_text({
            pos: pos,
            x_align: "left",
            y_align: "top",
            color: entry.color,
            text: entry.label})
    
        max_width = max(max_width, bounds.size.x)
        pos.y += bounds.height
        
        // Wrap into multiple columns
        if pos.y > list_rect.size.y - 8:
            pos.y = 0
            pos.x += max_width + 8
            max_width = 0
    
    draw_text({
        pos: list_rect.size,
        text: "..." + (player.board.word_count - size(player.history)) + " left",
        color: #DDD,
        x_align: "right",
        y_align: "bottom"})
    

        
        
def player_reset(player, seed):
    player.score = 0
    board_reset(player.board, seed)



let player = make_player()
