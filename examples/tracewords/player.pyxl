todo("Re-color")
todo("Sounds for big words")
todo("Allow scrolling the words at top")
todo("Show demons?")


/* Constructs a new player with an uninitialized board */
def make_player():
    
    // Capture the player variable for the argument-less callback
    def selection_change_callback():
        return player_selection_change_callback(player)
    
    
    const player = {
        board: make_board(),
        
        score: 0,
        
        gamepad: gamepad_array[0],
        
        // Q-encoded upper case words that have already been found
        // and are represented in history.list
        already_found: {},
        
        // Used for display.
        history: {
            // Each entry is {text, word, tiles, points, color, emphasize_frame}.
            // `word` is Q-encoded, text may contain arbitrary characters
            list: [],
            scroll: 0,

            // Scroll computation resets when screen size changes.
            // This was the size it was computed for.
            scroll_screen_size: xy(0, 0)},
        
        selection_change_callback: selection_change_callback,
        
        // Determined by most recent input method.
        // Show button prompts and cursor when using gamepad
        using_gamepad: false}
    
    // Fake history for layout debugging
    //for i < 30: player_add_to_history(player, "FOOBAR", 3 + 3 * i)
        
    return player



/* Called by the board after changing selection. 
   Returns true if there was a new word. As a side effect,
   plays a sound and sets the state for visualizing the word
   if there is one. */
def player_selection_change_callback(player):

    const board = player.board
    const word = board_selected_word(board)
    const points = score_word(word)

    // Reset selection color
    board.selection_color = TILE_CENTER_SELECTED_COLOR
    
    if player.already_found[word]:
        
        // Show that we've already seen this word by 
        // finding and emphasizing it
        player_emphasize_history_word(player, word)
        play_sound(select_tile_sound, false, 150%, ∅, 40%)
        return true
                
    else if points > 0:
        // Score the word, even without the player releasing their touch
        const color = player_add_to_history(player, word, points)
        todo("*Animation for scoring*")
        todo("Delay appearance of new word on the list until animation completes")
        todo("Delay appearance of points until animation completes")
        
        board.selection_color = color
        
        const pitch = 75% + min(max(0, points - 6)^0.1, 3)
        _board_play_sound(word_sound, 100% + 10% pitch, pitch, last_value(board.selection))
    
        return true



/* Returns the color. Updates the score. Does not verify that the word has
   not been found previously */ 
def player_add_to_history(player, word, points):
    player.already_found[word] = true
    
    let color = color_for_points(points)
    
    let text_color = color
    let outline = ∅
    
    // Super scorer colors
    if points ≥ 65:
        outline = lerp(color, #FFF, 40%)
        text_color = #FFF
    else if points ≥ 45:
        outline = color
        text_color = #FFF
    else if points ≥ 35:
        outline = lerp(color, #000, 25%)
        text_color = lerp(color, #FFF, 50%)
    
    push(player.history.list, {
        text:    q_decode(word) + ": " + points, 
        word:    word,
        tiles:   size(word), 
        emphasize_frame: 0,
        points:  points, 
        color:   text_color,
        outline: outline})
        
    player.score += points
     
    return color
    
    

/* Make this q-encoded word that is already in the history 
   appear emphasized for a few frames to make it obvious 
   to the player */
def player_emphasize_history_word(player, word, duration default 30):
    for entry in player.history.list:
        if entry.word == word:
            entry.emphasize_frame = game_frames + duration
            return
        
    assert(false, "Could not find " + word + " which should already be in history")



def _player_update_rotate_button(player, board_pos):
    let rotate_button_sprite = shapes.curved_arrow.rotated_270
    
    let rotate_button_pos = board_pos + xy(-4, -16) + xy(½, -½) board_pixel_size()
        
    draw_disk(rotate_button_pos, 8, ∅, #FFF)
    draw_sprite(rotate_button_sprite, rotate_button_pos + xy(1, 1), ∅, 38%)
    if player.using_gamepad:
        draw_text({font: tile_point_font, text: player.gamepad.prompt["(b)"], x_align: "right", pos: rotate_button_pos + xy(-6, 7), color: #FFF, outline: #000})

    if (touch.aa and overlaps({pos: rotate_button_pos, size: rotate_button_sprite.size}, touch.xy)) or joy.bb:
        push_mode(Rotate) because "Rotate button"


        
def _player_draw_score(player, board_pos):
    let score_pos = board_pos + xy(+½, -½) * board_pixel_size() - xy(40, 16)
        
    draw_text({
        pos: score_pos,
        font: score_font,
        text: format_number(player.score, "commas") + " pts",
        color: #FFF,
        y_align: "center",
        x_align: "right"})
    
    

/* Draws the count-down timer for `end_time` relative to the board */
def draw_clock(board_pos):  
    let clock_pos = board_pos + xy(-½, -½) * board_pixel_size() - xy(-28, 16)
    draw_text({
        pos: clock_pos,
        font: score_font,
        text: format_number(max(0, end_time - now()), "timer"),
        color: #FFF,
        y_align: "center",
        x_align: "right"})



/* Run UI for this player and draw their board */
def player_update(player, angle default 0°, allow_selection default false):
    // Track most recent UI method
    if touch.pressed_a:
        player.using_gamepad = false
    else if player.gamepad.aa or player.gamepad.bb or player.gamepad.dx or player.gamepad.dy:
        player.using_gamepad = true
    
    if not player.using_gamepad and not touch.a:
        resize(player.board.selection, 0)
    
    // Version/debugging
    draw_text({
        pos: xy(5, 0),
        font: tile_point_font,
        text: "Board \"" + player.board.seed + "\" on v" + CREDITS.version,
        color: #888,
        y_align: "top",
        x_align: "left",
        z: -1})

    let board_pos;
    
    // Our board has some content at the top, so don't switch
    // to portrait until all of the UI will be visible
    if landscape():
        // Landscape. Put at the bottom right (feel "closer" to a right handed mouse player)
        // Leave some space on the right so that if someone has the bad idea to play on a phone in this orientation
        // they won't be jammed against the edge with their thumb.
        board_pos = xy(SCREEN_SIZE.x - ½ board_pixel_size().x - 16, ½ SCREEN_SIZE.y + 12)
    else:
        // Portrait. Put at the bottom, centered, unless the screen is not very high
        board_pos = xy(½ SCREEN_SIZE.x, SCREEN_SIZE.y - ½ board_pixel_size().y - 18)
        
        // Slide up a little on narrow screens so that it is easier to swipe on a phone
        board_pos.y -= ⅓ max(SCREEN_SIZE.y - (board_pixel_size().y + 60), 0)
        
    board_update(
        player.board, board_pos, angle,
        if allow_selection then player.selection_change_callback else ∅)

    _player_draw_score(player, board_pos)
    
    if allow_selection:
        _player_update_rotate_button(player, board_pos)
        
    _player_draw_history(player, board_pos)
    draw_clock(board_pos)



/* `true` if in landscape layout mode */
def landscape():
    return SCREEN_SIZE.x + 28 > SCREEN_SIZE.y



def _player_draw_history(player, board_pos)
& preserving_transform:
    
    let list_rect
    if landscape():
        list_rect = {corner: xy(1, 20), size: xy(board_pos.x - ½ board_pixel_size().x - ¼ TILE_EXTENT + 1, SCREEN_SIZE.y - 22)}
    else:
        list_rect = {corner: xy(1, 0), size: xy(SCREEN_SIZE.x - 3, board_pos.y - ½ board_pixel_size().y - 32)}
    
    set_clip(list_rect)

    // Don't scroll this, draw it first
    draw_text({
        pos: list_rect.corner + list_rect.size - xy(2, 1),
        font: history_font,
        text: "" + size(player.history.list) + "/" + player.board.word_count,
        color: #DDD,
        x_align: "right",
        y_align: "bottom"})

    if not equivalent(SCREEN_SIZE, player.history.scroll_screen_size):
        player.history.scroll_screen_size = xy(SCREEN_SIZE)
        player.history.scroll = 0

    set_transform(list_rect.corner - xy(player.history.scroll, 0))
    const pos = xy(3, 2)
    let max_width = 0
    for entry at e in player.history.list:
        // Wrap into multiple columns if this element will
        // go off the page. Do this here so that we never
        // reset right before the end
        if pos.y > list_rect.size.y - 8:
            pos.y = 2
            pos.x += max_width + HISTORY_COLUMN_SEPARATION
            max_width = 0
            
        const emphasize = max(0, entry.emphasize_frame - game_frames)
        
        const wiggle = xy(oscillate(18% emphasize, -1, +1) - sign(emphasize), 0)
    
        const bounds = draw_text({
            // Bounce if emphasized
            pos: pos + wiggle,
            font: if emphasize then history_emphasis_font else history_font,
            x_align: "left",
            y_align: "top",
            color: entry.color,
            outline: if emphasize then #FFF else entry.outline,
            z: emphasize,
            text: entry.text})

        // Track if this makes the column larger
        max_width = max(max_width, text_width(history_font, entry.text))
        pos.y += history_font.line_height + 1
        
    // Set the scroll to whatever it needs to be to keep the 
    // most recent words on screen
    player.history.scroll = max(player.history.scroll, pos.x + max_width - list_rect.size.x)

    

/* Creates a random board, searching for good values as controlled by `BOARD_SEARCH` constants. */
def player_reset(player):
    player.score = 0
    remove_all(player.already_found)
    remove_all(player.history.list)
        
    let done = false
    let seed_word
    let word_array
    
    // Construct the rng based on the time. This will
    // cause players within the same window to be more likely
    // to have the same board. Temporary prior to investing
    // multiplayer servers.
    let board_rng = make_random(if DEBUG_BOARD_SEARCH then (now() * 10) else ⌊now() / (3 * 60)⌋)
    
    for i < BOARD_SEARCH.RETRIES:
        if i > 0: debug_print("*** Re-rolling ***") 

        // Search for a not-sensitive seed word to use
        while not seed_word or size(seed_word) > 8 or sensitive[seed_word]:
            seed_word = lowercase(q_decode(random_value(dictionary_array, board_rng)))
        
        // Loop for shuffling
        for j < BOARD_SEARCH.SHUFFLE_RETRIES:
            board_reset(player.board, seed_word, j)
                        
            word_array = board_find_all_words(player.board)
        
            if i == BOARD_SEARCH.RETRIES - 1 and j == BOARD_SEARCH.SHUFFLE_RETRIES - 1:
               // Last try, so just give up and accept the board
               debug_print("Gave up and accepted " + seed_word)
               done = true
               break
    
            if board_has_obvious_sensitive_word(player.board):
                debug_print("Reshuffled board " + seed_word + " because it had an obvious sensitive word")
                continue
    
            if size(word_array) < BOARD_SEARCH.MIN_WORDS:
                // Not enough words to even examine the board
                debug_print("Reshuffled board " + seed_word + " because it only produced " + size(word_array) + " words")        
                continue
    
            // Examine the actual words to see if there are enough good ones   
    
            // If a valuable letter appears, ensure that it is used in 
            // at least two words. First find high point value letters.
            const valuable_letter_table = {}
            for col in player.board.tile:
                for tile in col:
                    if LETTER_POINT_TABLE[tile.letter] ≥ 4:
                        valuable_letter_table[tile.letter] = 0
            
            const valuable_letters = keys(valuable_letter_table)
        
            // Iterate through words, rating them for each criterion
            let long_word_count = 0
            let very_long_word_count = 0
            for word in word_array:
                if size(word) ≥ 5:
                    ++long_word_count
                if size(word) ≥ 7:
                    ++very_long_word_count
                    
                for letter in valuable_letters:
                    if contains(word, letter):
                        ++valuable_letter_table[letter]
            
            if long_word_count < BOARD_SEARCH.MIN_LONG_WORDS:
                debug_print("Shuffled board " + seed_word + " because it only produced " + long_word_count + " long words")        
                continue
            
            if very_long_word_count < BOARD_SEARCH.MIN_VERY_LONG_WORDS:
                debug_print("Shuffled board " + seed_word + " because it only produced " + very_long_word_count + " very long words")        
                continue
            
            // See if we used the valuable letters
            let used_valuable_letters = true
            for count at letter in valuable_letter_table:
                if count < BOARD_SEARCH.MIN_VALUABLE_LETTER_USES:
                    used_valuable_letters = false
                    
            if not used_valuable_letters:
                debug_print("Shuffled board " + seed_word + " because it did not use all of the valuable letters")
                continue
    
            // Success!
            done = true
            break
    
        if done:
            // Stop early as we have a good board
            debug_print("Accepted board")
            break
        else:
            // Try again
            seed_word = ∅
        
    player.board.word_count = size(word_array)
    //debug_print(word_array)


let player = make_player()
