def make_player():
    return {
        board: make_board(),
        
        score: 0,
        
        gamepad: gamepad_array[0],
        
        // Determined by most recent input method.
        // Show button prompts and cursor when using gamepad
        using_gamepad: false,
        
        // {word, score} sorted by score
        word_array: []}
        


def _update_rotate_button(board_pos):
    let rotate_button_sprite = shapes.curved_arrow.x_flipped
    
    let rotate_button_pos = board_pos + xy(-4, -19) + xy(½, -½) board_pixel_size()
        
    draw_disk(rotate_button_pos, 10, ∅, #FFF)
    draw_sprite(rotate_button_sprite, rotate_button_pos + xy(0, -2), ∅, 50%)
    if player.using_gamepad:
        draw_text({font: tile_point_font, text: joy.prompt["(b)"], x_align: "right", pos: rotate_button_pos + xy(-6, 7), color: #FFF, outline: #000})

    if (touch.aa and overlaps({pos: rotate_button_pos, size: rotate_button_sprite.size}, touch.xy)) or joy.bb:
        push_mode(Rotate) because "Rotate button"


        
def _player_draw_score(player, board_pos):
    let score_pos = board_pos + xy(+½, -½) * board_pixel_size() - xy(40, 19)
        
    draw_text({
        pos: score_pos,
        font: font,
        text: format_number(player.score, "commas") + " pts",
        color: #FFF,
        y_align: "center",
        x_align: "right"})



todo("Move the rotate button to the right")

/* Run UI for this player and draw their board */
def player_update(player, angle default 0°, allow_selection default false):
    // Track most recent UI method
    if touch.pressed_a:
        player.using_gamepad = false
    else if player.gamepad.aa or player.gamepad.bb or player.gamepad.dx or player.gamepad.dy:
        player.using_gamepad = true
    
    if touch.released_a:
        todo("Release animation and sound")
        todo("Add to history")
        player.score += board_score_selection(player.board)

    draw_text({
        pos: xy(5, 5),
        font: tile_point_font,
        text: "Playing board \"" + player.board.seed + "\" on v" + CREDITS.version,
        color: #FFF,
        y_align: "top",
        x_align: "left"})

    let board_pos;
    
    // Our board has some content at the top, so don't switch
    // to portrait until all of the UI will be visible
    if SCREEN_SIZE.x + 28 > SCREEN_SIZE.y:
        // Landscape. Put at the bottom right (feel "closer" to a right handed mouse player)
        // Leave some space on the right so that if someone has the bad idea to play on a phone in this orientation
        // they won't be jammed against the edge with their thumb.
        board_pos = xy(SCREEN_SIZE.x - ½ board_pixel_size().x - 16, ½ SCREEN_SIZE.y + 12)
    else:
        // Portrait. Put at the bottom, centered, unless the screen is not very high
        board_pos = xy(½ SCREEN_SIZE.x, SCREEN_SIZE.y - ½ board_pixel_size().y - 18)
        
        // Slide up a little on narrow screens so that it is easier to swipe on a phone
        board_pos.y -= ⅓ max(SCREEN_SIZE.y - (board_pixel_size().y + 60), 0)
        
    board_update(player.board, board_pos, angle, player.history, allow_selection)

    _player_draw_score(player, board_pos)
    
    if allow_selection:
        _update_rotate_button(board_pos)
        
        
        
def player_reset(player, seed):
    player.score = 0
    board_reset(player.board, seed)



let player = make_player()
        