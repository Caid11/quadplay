/*
 Routines for working with words.
 
 The dictionary contains 280k words.
 
 There are about 250 unique 3-grams and 1000 unique 4-grams 
 on typical a board. There are about 5000 unique 5-grams.
 
 Computing these n-grams and filtering the entire
 dictionary by them are both practically instantaneous. This 
 quickly gives a short list of possible words to investigate
 more deeply with search.
  
 3-gram filtering:
  - prefixes 280k -> 11k
  - + suffixes -> 1k
  - + middle -> 500

 4-gram filtering:
 - prefixes 280k -> 3k
 - + suffixes -> 300
 - + middle -> 200
 
 5-grams cut this about 10-15% more, so there is not
 much payoff for going to 6-grams.
 
 There are also rapidly diminishing returns making more
 than three tests with n-grams, due to repeated letters on
 the board.
 
 After this filtering, all 3, 4, and 5 letter words 
 found are *definitely* on the board. Longer words are
 *possibly* on the board and must be searched for explicitly
 to validate.
 
 Running the whole filter, this leaves about 10 words
 of 6+ letters to validate.
 
 The full boggle board contains about 57M possible sequences
 (nodes in the search tree).
*/

/* Longest possible word */
const MAX_WORD_LENGTH = ROWS * COLS

/* Cleaned dictionary table of about 280k words with:
 
   - No capitalized words
   - No words shorter than `MIN_WORD_LENGTH`
   - No words with "q" not followed by "u"
   - All words capitalized
   - All "qu" replaced with "q", so that it counts as a single letter/tile
     for comparison purposes
     
   Use `q_decode()` for expanding the "q" back to "qu" before displaying
   to the user.
*/
const dictionary = {}

// Compute `dictionary`
for word in keys(dictionary_source):
    // Use JavaScript regexp undocumented quadplay feature to exclude 
    // words with capital letters or q without u. Also ensure the word
    // does not end in a q (without u).
    //
    // We have to check max word length after q encoding because there
    // are 30 words with 2 qs, which change the length.
    if (size(word) ≥ MIN_WORD_LENGTH and       
       not word.match(/q[^u]/g) and
       lowercase(word) == word and
       last_value(word) ≠ "q"):
           
        const w = replace(word, "qu", "q")
        const n = size(w)
        
        if n ≥ MIN_WORD_LENGTH and n ≤ MAX_WORD_LENGTH:
            dictionary[uppercase(w)] = 1

/* Array of all of the words in `dictionary` */
const dictionary_array = keys(dictionary)
debug_print(format_number(size(dictionary_array), "commas"), "total words in dictionary")


/* Replace "Q" with "QU" */
def q_decode(word):
    return replace(word, "Q", "QU")
    

/* Computes the letter points and size multiplier. Assumes
   word is an all-uppercase string with only legal characters
   and is Q-encoded (Q appears without U).*/
def score_word(word):
    let score = 0
    for letter in word:
        score += LETTER_POINT_TABLE[letter] || 0
    
    // Length multiplier (# tiles, not letters)
    score *= min(5, size(word) - MIN_WORD_LENGTH + 1)
    
    return score

