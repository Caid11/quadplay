/*
quad://scripts/dice.pyxl

Copyright 2024, Morgan McGuire
Open source under the MIT license
https://opensource.org/licenses/MIT

Depends on quad://scripts/mat3x3.pyxl

───────────────────────────────────────────────


Usage:

// Prepare:
dice = make_dice(…)
die0 = dice_add_die(dice, …)
die1 = dice_add_die(dice, …)
…


// Set the desired result. Do this
// before every roll.
die0.result_index = random_integer(…)
…
dice_set_initial_positions(dice)
dice_preroll(dice)


///////////////////////////////////
// Animate in the main loop
dice_update(dice, …)


// Frames left on the current roll
const t = dice_roll_time(dice)

*/

let _dice_geometry_cache = {}

def make_dice(
    pos default xy(0, 0), 
    size default SCREEN_SIZE,
    shadow_color default #444,
    die_sound default ∅,
    table_sound default ∅,
    wall_sound default ∅):
        
    const dice = {
        pos: pos,
        size: size,
        physics: make_physics({gravity: xy(0, 0)}),
        shadow_color: rgb(shadow_color),
        wall_sound: wall_sound,
        table_sound: table_sound,
        die_sound: die_sound,
        die_array: []}
    
    physics_add_contact_callback(dice.physics, _dice_collision_callback, 0.5)
    
    const WALL_THICKNESS = 10
    
    // Add walls
    const WALL_TEMPLATE = {    
        shape: "rect", 
        restitution: 90%,
        friction: 0,
        density: ∞}
        
    physics_add_entity(dice.physics, make_entity({
        …WALL_TEMPLATE,
        name: "right_wall",
        size: xy(WALL_THICKNESS, size.y), 
        pos: pos + xy(½ size.x + ½ WALL_THICKNESS, 0)}))
        
    physics_add_entity(dice.physics, make_entity({
        …WALL_TEMPLATE,
        name: "left_wall",
        size: xy(WALL_THICKNESS, size.y), 
        pos: pos + xy(-½ size.x - ½ WALL_THICKNESS, 0)}))

    physics_add_entity(dice.physics, make_entity({
        …WALL_TEMPLATE,
        name: "bottom_wall",
        size: xy(size.x, WALL_THICKNESS), 
        pos: pos + xy(0, -½ size.y - ½ WALL_THICKNESS)}))
        
    physics_add_entity(dice.physics, make_entity({
        …WALL_TEMPLATE,
        name: "top_wall",
        size: xy(size.x, WALL_THICKNESS), 
        pos: pos + xy(0, ½ size.y + ½ WALL_THICKNESS)}))

    return dice
    


/* bright_color may be a color or a hue percentage.
   label_array may be an array of strings, sprites, or numbers */
def dice_add_die(dice, sides, pos default xy(0, 0), radius default 12, font default ∅, label_array default ∅, bright_color default ∅, dim_color default ∅, label_color default #FFF, shadow_color default #888):
    ++dice_add_die.count
    
    // Dice with more sides roll better
    const base_drag = 0.0008 * (20 / sides)²
    
    const die = make_entity({
        // Entity base properties
        name: "d" + sides + "_" + dice_add_die.count,
        shape: "disk",
        pos: xy(pos),
        vel: xy(0, 0),
        size: 2.1 radius * xy(1, 1),
        
        // Entity physics properties
        drag: base_drag,
        base_drag: base_drag,
        friction: 0,
        restitution: 90%,
        
        // Extended properties
        sides: sides,
        rotation: mat3x3_identity(),
        model: _dice_DATA_TABLE["d" + sides],
        result_index: sides - 1,
        label_font: font,
        label_color: label_color,
        label_array: label_array,
        bright_color: bright_color,
        dim_color: dim_color,
        
        // Array of positions and rotations
        history: [],
        
        // Increases with velocity each frame,
        // used to play the table sound for simulating
        // faces flipping over
        tumble_count: 0,
        
        draw: _dice_die_draw,
        dice: dice})
    
    die.rotation = die_rotation_for_result(die)
    
    if bright_color == ∅ or is_number(bright_color):
        const hue = bright_color default ξ
        die.bright_color = artist_hsv_to_rgb(hue, 100%, 75%)
        die.dim_color = artist_hsv_to_rgb(hue + 22%, 88%, 40%)
    
    physics_add_entity(dice.physics, push(dice.die_array, die))

    return die
    
dice_add_die.count = 0    
    


/* Move from old to new set */
def dice_insert(dice, die):
    dice_remove(die.dice, die)
    
    // Add
    die.dice = dice
    push(die.dice.die_array, die)
    physics_add_entity(die.dice.physics, die)
    
    // Reposition
    die.pos = random_within_region(dice)
    dice_correct_overlaps(dice)

    

def dice_remove(dice, die):
    assert(contains(dice.die_array, die))
    remove_values(die.dice.die_array, die)
    physics_remove_entity(die.dice.physics, die)
    

    
/* Fix any out of bounds or overlapping dice */
def dice_correct_overlaps(dice):
    // Relaxation to avoid overlap in initial positions
    for k < 2 size(dice.die_array):
        for A at i in dice.die_array:
            for i < j < size(dice.die_array):
                const B = dice.die_array[j]
                const offset = A.pos - B.pos
                if ‖offset‖ < ½ (A.size.x + B.size.x):
                    const shift = xy(dice.size.x / dice.size.y, 1) * 400 direction(offset) / max(10, magnitude(offset))²
                    A.pos += shift
                    B.pos -= shift
                
            // Keep in the dice tray and well away from sides
            const side = max(½ dice.size - A.size, xy(0, 0))
            A.pos = clamp(A.pos, dice.pos - side, dice.pos + side)
    


def die_rotation_for_result(die):
    const normal = die.model.geometry.face_array[die.model.unmap[die.result_index]].normal
    const R = mat3x3_rotation_between(normal, xyz(0, 0, 1))
    
    if die.sides == 4:
        // The 4-sided die is a weird case because it does
        // not have a top face. We draw it rotated to look
        // plausibly like it is standing up.
        if die.result_index < 2:
            return mat3x3_mul(mat3x3_roll(-10°), mat3x3_mul(mat3x3_pitch(45°), R))
        else:
            return mat3x3_mul(mat3x3_mul(mat3x3_pitch(45°), mat3x3_roll(60°)), R)
    else:
        return R



def _dice_die_draw(die):
    _dice_die_model_draw(
        die.model, 
        die.pos, 
        die.rotation,
        die.bright_color,
        die.dim_color,
        die.dice.shadow_color,
        ½ die.size.x * |die.scale.x|,
        die.label_array,
        die.label_color,
        die.label_font)
        

/*
 Draw a convex solid polyhedral die with slightly 
 rounded edges, drop shadow, and a label on its top
 face.
 
 Assumes the ground plane is at z = 0.
 
 rotation = 3x3 rotation matrix (see 3D.pyxl for helpers)
 pos = xyz() translation
 
 label_array is an array of strings or sprites. The default
 value maps each face to a number, based on 1.
 
 With zero rotation, label[0] will appear on the top face.
*/
def _dice_die_model_draw(
    model, 
    pos default xyz(0, 0, 0), 
    rotation default [[1, 0, 0], [0, 1, 0], [0, 0, 1]],
    bright_color default rgb(1, 0, 0),
    dim_color default 60% bright_color,
    shadow_color default #888,
    radius default 12,
    label_array default ∅,
    label_color default #FFF,
    label_font default ∅)
& preserving_transform:
    
    set_transform(∅, xy(1, -1))
    
    // For the 4-sided die, draw the "top" face at a lower threshold
    // since it doesn't sit flat
    const shaded_face_threshold = if model.sides > 4 then 92% else 70%
        
    if label_array == ∅:
        label_array = []
        for i < model.sides:
            push(label_array, "" + (i + 1))

    if _dice_geometry_cache[model.sides] == ∅:
        _dice_geometry_cache[model.sides] = deep_clone(model.geometry)
        
    // Use the cached copy to minimize allocations
    const src_geometry = model.geometry
    const dst_geometry = _dice_geometry_cache[model.sides]
        
    // Apply the base transformation first
    const scale = radius
    
    const light_dir = direction(xyz(-1, 2, 0.5))
    const view_dir = xyz(0, 0, 1)
    const half_dir = direction(light_dir + view_dir)
    const edge_thickness = 1
    
    const shadow_offset = -½ radius * xy(light_dir)
    
    def shade(N, intensity):
        // Wrap shading
        const β = MAX(0, MAD(60%, XYZ_DOT_XYZ(N, light_dir), 40%))
        const diffuse_color = lerp(dim_color, bright_color, β)
        
        // Scalar because we assume white light
        const glossy_intensity = intensity * MAX(0, XYZ_DOT_XYZ(N, half_dir))³
        return diffuse_color + glossy_intensity
        

    // Draws the label on a face. Assums N.z > 10%        
    def draw_label(N, label, centroid):
        const label_z = pos.z + 140% radius
        const underscore = (label == 6 or label == 9 or label == "6" or label == "9")
        if N.z > shaded_face_threshold: // Top face
            const label_shadow_opacity = 15%
            const label_highlight_opacity = 40%
            
            if label.spritesheet == ∅:

                // Inset
                draw_text({
                    font: label_font, 
                    text: label, 
                    z: label_z,
                    pos: centroid + xyz(0, +1, 0),
                    color: rgba(0, 0, 0, label_shadow_opacity)})
                 
                if underscore:
                    draw_text({
                        font: label_font, 
                        text: "_", 
                        z: label_z,
                        pos: centroid,
                        color: rgba(0, 0, 0, label_shadow_opacity)})
                    
                   
                // Label and shadow
                draw_text({
                    font: label_font, 
                    text: label, 
                    pos: centroid,
                    z: label_z,
                    color: label_color,
                    shadow: rgba(1, 1, 1, label_highlight_opacity)})
                 
                if underscore:                 
                    draw_text({
                        font: label_font, 
                        text: "_", 
                        pos: centroid + xyz(0, -1, 0),
                        z: label_z,
                        color: label_color,
                        shadow: rgba(1, 1, 1, label_highlight_opacity)})
                    
            else:
                // Sprite label
                draw_sprite({sprite: label, z: label_z, pos: centroid + xyz(0, 1, 0), override_color: #000, opacity: label_shadow_opacity})
                draw_sprite({sprite: label, z: label_z, pos: centroid + xyz(0, -1, 0), override_color: #FFF, opacity: label_highlight_opacity})
                draw_sprite({sprite: label, z: label_z, pos: centroid})
        
        else: // Side face
            
            let α = max(N.z - 0.05, 0)
            if model.sides == 20:
                // d20 has too many labels, make them
                // fade off more quickly
                α = α³ 
            else if model.sides == 8 or model.sides == 4:
                // Steep angles
                α = α^(1.5)
            else:
                α = α²
                
            if label.spritesheet:
                draw_sprite({sprite: label, pos: centroid, opacity: α, z: label_z})//, angle: round(270° - xy_to_angle(centroid), 22.5 * 1°)})
            else:
                draw_text({font: label_font, pos: centroid, text: label, color: rgba(label_color.r, label_color.g, label_color.b, α), z: label_z})
                if underscore:
                    draw_text({font: label_font, pos: centroid + xyz(0, -1, 0), text: "_", color: rgba(label_color.r, label_color.g, label_color.b, α), z: label_z})


    // Ensure 3D pos, fix alignment to bounding dice
    if pos.z == ∅: 
        pos = xyz(pos.x - 0.5, pos.y + 0.5, 0)
    else:
        pos = pos + xyz(-0.5, +0.5, 0)
        
    // Put on top of surface
    pos = pos + xyz(0, 0, radius)
    
    // The vertex transform incorporates the scale
    const S = mat3x3_scale(scale)
    const SR = mat3x3_mul(S, rotation)
    
    // Transform all points and normals
    const vertex_array = dst_geometry.vertex_array
    for v < size(vertex_array):
        const V = vertex_array[v]
        MAT3x3_MATMUL_XYZ(SR, src_geometry.vertex_array[v], V)
        XYZ_ADD_XYZ(V, pos, V)
    
    // Faces
    const face_array = dst_geometry.face_array
    for f < size(face_array):
        const src_face = src_geometry.face_array[f]
        const dst_face = face_array[f]
        const N = dst_face.normal
        MAT3x3_MATMUL_XYZ(rotation, src_face.normal, N)
        dst_face.z = -∞

        // Draw if front face
        if N.z ≥ 0:            
            const poly = []
            const centroid = xyz(0, 0, 0)
            for i < size(dst_face.index_array):
                const V = vertex_array[dst_face.index_array[i]]
                push(poly, V)
                XYZ_ADD_XYZ(centroid, V, centroid)
                dst_face.z = max(dst_face.z, V.z)
            
            // Face
            draw_poly(poly, shade(N, 60%), ∅, ∅, ∅, ∅, dst_face.z)
            
            // Shadow
            draw_poly(poly, shadow_color, ∅, shadow_offset, ∅, ∅, 0)
            
            XYZ_MUL(centroid, 1 / size(dst_face.index_array), centroid)
            
            const label = label_array[model.remap[f]]
            if N.z > 10% and label:
                draw_label(N, label, centroid)
    
    // Edges
    const edge_array = dst_geometry.edge_array
    for e < size(edge_array):
        const edge = edge_array[e]
        const face0 = face_array[edge.face_index_array[0]]
        const face1 = face_array[edge.face_index_array[1]]

        // Use the max of the face z values to ensure
        // the edge overdraws correctly
        const z = max(face0.z, face1.z)
        
        // Draw if either edge is a front, treating as a sliver polygon
        if z > -∞:
            const N = edge.normal
            MAT3x3_MATMUL_XYZ(rotation, src_geometry.edge_array[e].normal, N)
            
            const V0 = vertex_array[edge.index_array[0]]
            const V1 = vertex_array[edge.index_array[1]]
            
            const color = shade(N, 75%)
                        
            if min(face0.z, face1.z) == -∞:
                // Silhouette edge, darken, thicken and push back
                draw_line(V0, V1, 70% color, z - ε, 2)
            else:
                // Front face. Push away from the vertices
                // to highlight/smooth the center of the edge
                // only
                const dir = direction(V1 - V0)
                draw_line(V0 + dir, V1 - dir, color, z, edge_thickness)

    // Visualize bounds    
    if false:
        draw_disk(xy(0, 0), radius, ∅, #FFF)
        draw_rect(xy(0, 0), xy(2, 2) * radius, ∅, #FFF)



def dice_set_initial_positions(dice):
    // Distribute the dice randomly
    for die at i in dice.die_array:
        die.pos = random_within_region(dice)
    
    dice_correct_overlaps(dice)
    
    
/* Run simulation until termination */
def _dice_preroll_simulate(dice):
    assert(size(dice.die_array) > 0)
    
    // Erase previous history, set initial velocity
    for die in dice.die_array:
        die.vel = 5 random_on_circle()
        die.drag = die.base_drag
        die.history = []
    
    let any_awake = true

    // Fail-safe
    const MAX_STEPS = 400
    let steps = 0
    
    while any_awake and steps < MAX_STEPS:
        any_awake = false
        ++steps
        
        physics_simulate(dice.physics)
            
        for die in dice.die_array:
            const speed = ‖die.vel‖
                
            if speed < 1.5:
                // Add drag when moving slowly, so that they tend to stop
                // in the middle instead of near walls
                die.drag = 15 die.base_drag
                //draw_disk(die.pos, 20, ∅, #F00)
                
            if die.physics_sleep_state ≠ "sleeping": 
                any_awake = true
            
            // Rotate based on velocity, adding some yaw
            const tumble_axis = direction(xyz(-die.vel.y, die.vel.x, 30% die.vel.x))
            const R = mat3x3_from_axis_angle(tumble_axis, 150 deg ‖die.vel‖ / |die.size.x * die.scale.x|)
            die.rotation = mat3x3_mul(R, die.rotation, true) 
            assert(not is_NaN(die.pos.x) and not is_NaN(die.rotation[0][0]))

            const [axis, angle] = mat3x3_to_axis_angle(die.rotation)
            const state = {pos:xy(die.pos), axis: axis, angle: angle}

            const old = die.tumble_count
            die.tumble_count += 1% speed * die.sides
            if ⌊die.tumble_count⌋ > ⌊old⌋:
                // Play a sound
                state.sound_data = {sound: dice.table_sound, pan: xy(die.pos), pitch: 50% - die.sides / 60, volume: clamp(3% speed, 2%, 10%)}
                
            push(die.history, state)

            
    assert(size(dice.die_array[0].history) > 0)



def _dice_collision_callback(args):
    const die = if args.entityA.history then args.entityA else args.entityB
    if die.history and size(die.history) > 0:
        let sound_data
        
        if max(args.entityA.density, args.entityB.density) == ∞:
            // Wall
            sound_data = {
                sound: die.dice.wall_sound,
                volume: 25% args.depth}
        else:
            // Dice                
            sound_data = {
                sound: die.dice.die_sound,
                pitch: 200% - die.sides / 20, 
                volume: 35% args.depth}
            
        last_value(die.history).sound_data = sound_data



/* Adjust stored history rotations to achieve 
   `die.result_index` on each `die` */
def _dice_adjust_result(dice):
    assert(size(dice.die_array[0].history) > 0)
    for die in dice.die_array:
        // Rotation that makes face[current] point up
        const desired = die_rotation_for_result(die)
        const last_state = last_value(die.history)
        assert(last_state)
        const actual = mat3x3_from_axis_angle(last_state.axis, last_state.angle)
        
        const change = mat3x3_mul(mat3x3_transpose(actual), desired)
        
        // Apply transformation to all history to achieve final result,
        // but start after the first frame to hide the initial transformation
        for 1 ≤ f < size(die.history):
            const state = die.history[f]
            let M = mat3x3_from_axis_angle(state.axis, state.angle)

            M = mat3x3_mul(M, change)
            const [axis, angle] = mat3x3_to_axis_angle(M)
            state.axis = axis
            state.angle = angle



/* Remaining frames on the rolling animation to reach the final state */
def dice_roll_time(dice):
    if size(dice.die_array) > 0:
        return size(dice.die_array[0].history) - 1
    else:
        return 0
      
     
     
def _dice_simulate(dice):        
    if dice_roll_time(dice) > 0:
        for die in dice.die_array:
            pop_front(die.history)
            const state = die.history[0]
            die.rotation = mat3x3_from_axis_angle(state.axis, state.angle)
            die.vel = state.pos - die.pos
            die.pos = state.pos
            
            if state.sound_data:
                play_sound({…state.sound_data, pos: die.pos})
            
        
        
def _dice_draw(dice):
    for die in dice.die_array:
        _dice_die_draw(die)
   
   
   
def dice_update(dice):
    _dice_simulate(dice)
    _dice_draw(dice)
    
    
    
/* If `random_results` is `false` then result_index is unmodified for each die */
def dice_prepare_roll(dice, random_results default true):
    if random_results:
        for die in dice.die_array:
            die.result_index = random_integer(0, die.sides - 1)
            
    _dice_preroll_simulate(dice)
    _dice_adjust_result(dice)


// Remap the geometry faces to the labels.
//
// label_index = die.model.remap[face]
// result = die.model.unmap[label_index]

const _dice_DATA_TABLE = {
    "d4":{"remap":[0, 1, 2, 3], "geometry":{"vertex_array":[{"x":-0.9166666666666666,"y":-0.6376290442079258,"z":-0.11243120417720794},{"x":0.9166666666666666,"y":-0.6376290442079258,"z":-0.11243120417720782},{"x":0,"y":0.47845154801323964,"z":1.0151716444383985},{"x":0,"y":0.7968065404026119,"z":-0.7903092360839827}],"face_array":[{"index_array":[0,1,2],"normal":{"x":0,"y":-0.7107290586752417,"z":0.7034654144701108}},{"index_array":[0,2,3],"normal":{"x":-0.816195,"y":0.5689981900003974,"z":0.10033028432415873}},{"index_array":[3,1,0],"normal":{"x":0,"y":-0.42726750993352125,"z":-0.9041249134694874}},{"index_array":[3,2,1],"normal":{"x":0.816195,"y":0.5689983758932027,"z":0.10032923007367195}}],"edge_array":[{"index_array":[0,1],"face_index_array":[0,2],"normal":{"x":0,"y":-0.984807753012208,"z":-0.17364817766693033}},{"index_array":[0,2],"face_index_array":[1,0],"normal":{"x":-0.707106,"y":-0.1227878419655301,"z":0.6963644558092034}},{"index_array":[0,3],"face_index_array":[2,1],"normal":{"x":-0.707107,"y":0.12278766831735245,"z":-0.6963634710014504}},{"index_array":[1,2],"face_index_array":[0,3],"normal":{"x":0.707107,"y":-0.12278766831735245,"z":0.6963634710014504}},{"index_array":[1,3],"face_index_array":[3,2],"normal":{"x":0.707106,"y":0.1227878419655301,"z":-0.6963644558092034}},{"index_array":[2,3],"face_index_array":[1,3],"normal":{"x":0,"y":0.984807753012208,"z":0.17364817766693033}}]},"sides":4},
    "d6":{"remap":[0, 1, 2, 4, 3, 5], "geometry":{"vertex_array":[{"x":0.7083333333333334,"y":-0.7083333333333334,"z":-0.7083333333333334},{"x":-0.7083333333333334,"y":-0.7083333333333334,"z":-0.7083333333333334},{"x":-0.7083333333333334,"y":0.7083333333333334,"z":-0.7083333333333334},{"x":0.7083333333333334,"y":0.7083333333333334,"z":-0.7083333333333334},{"x":-0.7083333333333334,"y":-0.7083333333333334,"z":0.7083333333333334},{"x":-0.7083333333333334,"y":0.7083333333333334,"z":0.7083333333333334},{"x":0.7083333333333334,"y":0.7083333333333334,"z":0.7083333333333334},{"x":0.7083333333333334,"y":-0.7083333333333334,"z":0.7083333333333334}],"face_array":[{"index_array":[0,1,2,3],"normal":{"x":0,"y":0,"z":-1}},{"index_array":[2,1,4,5],"normal":{"x":-1,"y":0,"z":0}},{"index_array":[6,3,2,5],"normal":{"x":0,"y":1,"z":0}},{"index_array":[3,6,7,0],"normal":{"x":1,"y":0,"z":0}},{"index_array":[1,0,7,4],"normal":{"x":0,"y":-1,"z":0}},{"index_array":[5,4,7,6],"normal":{"x":0,"y":0,"z":1}}],"edge_array":[{"index_array":[0,1],"face_index_array":[0,4],"normal":{"x":0,"y":-0.707107,"z":-0.707107}},{"index_array":[6,7],"face_index_array":[3,5],"normal":{"x":0.707107,"y":0,"z":0.707106}},{"index_array":[0,3],"face_index_array":[3,0],"normal":{"x":0.707106,"y":0,"z":-0.707107}},{"index_array":[0,7],"face_index_array":[4,3],"normal":{"x":0.707107,"y":-0.707107,"z":0}},{"index_array":[5,6],"face_index_array":[2,5],"normal":{"x":0,"y":0.707107,"z":0.707107}},{"index_array":[1,2],"face_index_array":[0,1],"normal":{"x":-0.707107,"y":0,"z":-0.707107}},{"index_array":[1,4],"face_index_array":[1,4],"normal":{"x":-0.707107,"y":-0.707107,"z":0}},{"index_array":[2,3],"face_index_array":[0,2],"normal":{"x":0,"y":0.707107,"z":-0.707107}},{"index_array":[4,7],"face_index_array":[5,4],"normal":{"x":0,"y":-0.707107,"z":0.707107}},{"index_array":[2,5],"face_index_array":[2,1],"normal":{"x":-0.707107,"y":0.707107,"z":0}},{"index_array":[4,5],"face_index_array":[1,5],"normal":{"x":-0.707107,"y":0,"z":0.707107}},{"index_array":[3,6],"face_index_array":[3,2],"normal":{"x":0.707107,"y":0.707107,"z":0}}]},"sides":6},
    "d8":{"remap":[0, 4, 6, 2, 3, 7, 1, 5], "geometry":{"vertex_array":[{"x":0.8840725,"y":0.5915599679901917,"z":0.6569939037218636},{"x":0,"y":-0.9289310318467427,"z":0.8364132579485728},{"x":0.8840725,"y":-0.5915599679901917,"z":-0.6569939037218636},{"x":-0.8840725,"y":0.5915599679901917,"z":0.6569939037218636},{"x":-0.8840725,"y":-0.5915599679901917,"z":-0.6569939037218636},{"x":0,"y":0.9289310318467427,"z":-0.8364132579485728}],"face_array":[{"index_array":[0,1,2],"normal":{"x":0.816439,"y":-0.4291148597202372,"z":0.3863767551604018}},{"index_array":[3,4,1],"normal":{"x":-0.816438,"y":-0.42911634600988824,"z":0.3863780934216146}},{"index_array":[1,0,3],"normal":{"x":0,"y":0.11718872025995719,"z":0.9931098424589465}},{"index_array":[4,2,1],"normal":{"x":0,"y":-0.9754199259900825,"z":-0.22035499387693014}},{"index_array":[5,2,4],"normal":{"x":0,"y":-0.11718872025995719,"z":-0.9931098424589465}},{"index_array":[3,0,5],"normal":{"x":0,"y":0.9754199259900825,"z":0.22035499387693014}},{"index_array":[5,4,3],"normal":{"x":-0.816439,"y":0.4291156028650626,"z":-0.38637742429100813}},{"index_array":[5,0,2],"normal":{"x":0.816438,"y":0.42911634600988824,"z":-0.3863780934216146}}],"edge_array":[{"index_array":[0,1],"face_index_array":[0,2],"normal":{"x":0.49994700000000003,"y":-0.19100880471346246,"z":0.8447301465290169}},{"index_array":[0,2],"face_index_array":[7,0],"normal":{"x":1,"y":0,"z":0}},{"index_array":[0,3],"face_index_array":[2,5],"normal":{"x":0,"y":0.6691306063588582,"z":0.7431448254773942}},{"index_array":[0,5],"face_index_array":[5,7],"normal":{"x":0.49994599999999995,"y":0.8600684832280466,"z":-0.10166409440312331}},{"index_array":[1,2],"face_index_array":[0,3],"normal":{"x":0.49994700000000003,"y":-0.8600684832280466,"z":0.10166409440312328}},{"index_array":[1,4],"face_index_array":[3,1],"normal":{"x":-0.49994599999999995,"y":-0.8600684832280466,"z":0.10166409440312331}},{"index_array":[1,3],"face_index_array":[1,2],"normal":{"x":-0.49994599999999995,"y":-0.19100880471346252,"z":0.8447301465290169}},{"index_array":[2,4],"face_index_array":[4,3],"normal":{"x":0,"y":-0.6691306063588582,"z":-0.7431448254773942}},{"index_array":[2,5],"face_index_array":[7,4],"normal":{"x":0.49994599999999995,"y":0.19100880471346252,"z":-0.8447301465290169}},{"index_array":[3,4],"face_index_array":[1,6],"normal":{"x":-1,"y":0,"z":0}},{"index_array":[3,5],"face_index_array":[6,5],"normal":{"x":-0.49994700000000003,"y":0.8600684832280466,"z":-0.10166409440312328}},{"index_array":[4,5],"face_index_array":[4,6],"normal":{"x":-0.49994700000000003,"y":0.19100880471346246,"z":-0.8447301465290169}}]},"sides":8},
    "d10":{"remap":[0, 8, 1, 5, 6, 4, 7, 3, 2, 9], "geometry":{"vertex_array":[{"x":0,"y":0.9510565162951535,"z":0.3090169943749474},{"x":0.8674562703721571,"y":0.18750330838818283,"z":-0.23543444080361964},{"x":0.5361170213728716,"y":0.12761852919852631,"z":-0.7344108509414091},{"x":0,"y":0.3822593397164907,"z":-0.8348318721883408},{"x":0.5361171652602079,"y":-0.12761836040517174,"z":0.7344103314488806},{"x":0.867455677210434,"y":-0.18750343947316572,"z":0.23543484424171346},{"x":0,"y":-0.9510565162951535,"z":-0.3090169943749474},{"x":-0.5361171652602079,"y":0.12761836040517174,"z":-0.7344103314488806},{"x":-0.867455677210434,"y":0.18750343947316572,"z":-0.23543484424171346},{"x":-0.5361170213728716,"y":-0.12761852919852631,"z":0.7344108509414091},{"x":0,"y":-0.3822593397164907,"z":0.8348318721883408},{"x":-0.8674562703721571,"y":-0.18750330838818283,"z":0.23543444080361964}],"face_array":[{"index_array":[0,1,2,3],"normal":{"x":0.4534024401801491,"y":0.7980794813582818,"z":-0.3968574334085002}},{"index_array":[1,0,4,5],"normal":{"x":0.733619661117717,"y":0.5315766578301304,"z":0.42335391917481363}},{"index_array":[2,1,5,6],"normal":{"x":0.733619654646549,"y":-0.5315764166606355,"z":-0.4233546614181978}},{"index_array":[3,2,6,7],"normal":{"x":0,"y":-0.36686874018878707,"z":-0.9302727657419936}},{"index_array":[0,3,7,8],"normal":{"x":-0.45340167341660187,"y":0.7980794490094587,"z":-0.3968573338490596}},{"index_array":[4,0,9,10],"normal":{"x":0,"y":0.36686874018878707,"z":0.9302727657419936}},{"index_array":[5,4,10,6],"normal":{"x":0.45340167341660187,"y":-0.7980794490094587,"z":0.3968573338490596}},{"index_array":[7,6,11,8],"normal":{"x":-0.733619661117717,"y":-0.5315766578301304,"z":-0.42335391917481363}},{"index_array":[0,8,11,9],"normal":{"x":-0.7336202424318012,"y":0.5315766666606355,"z":0.4233538919973135}},{"index_array":[10,9,11,6],"normal":{"x":-0.4534024401801491,"y":-0.7980794813582818,"z":0.3968574334085002}}],"edge_array":[{"index_array":[0,1],"face_index_array":[0,1],"normal":{"x":0.6658887345533389,"y":0.7459030603708008,"z":0.014863369955244399}},{"index_array":[9,11],"face_index_array":[9,8],"normal":{"x":-0.8090169943749475,"y":-0.1816356320013402,"z":0.5590169943749475}},{"index_array":[0,3],"face_index_array":[4,0],"normal":{"x":0,"y":0.895404332278156,"z":-0.44525423338078374}},{"index_array":[0,4],"face_index_array":[1,5],"normal":{"x":0.41154195888934114,"y":0.5040046410130604,"z":0.7593501528812778}},{"index_array":[9,10],"face_index_array":[5,9],"normal":{"x":-0.3090171472195055,"y":-0.2938925640948282,"z":0.904508306212876}},{"index_array":[0,8],"face_index_array":[8,4],"normal":{"x":-0.6658889624223508,"y":0.7459029497479648,"z":0.014863710417325593}},{"index_array":[0,9],"face_index_array":[5,8],"normal":{"x":-0.41154230018133986,"y":0.5040047216553201,"z":0.7593499046899231}},{"index_array":[8,11],"face_index_array":[8,7],"normal":{"x":-0.9999998562569681,"y":0,"z":0}},{"index_array":[1,2],"face_index_array":[0,2],"normal":{"x":0.8090169943749475,"y":0.1816356320013402,"z":-0.5590169943749475}},{"index_array":[7,8],"face_index_array":[4,7],"normal":{"x":-0.8090172832402858,"y":0.18163575190584186,"z":-0.5590173634030582}},{"index_array":[1,5],"face_index_array":[2,1],"normal":{"x":1,"y":0,"z":0}},{"index_array":[2,3],"face_index_array":[0,3],"normal":{"x":0.3090171472195055,"y":0.2938925640948282,"z":-0.904508306212876}},{"index_array":[6,11],"face_index_array":[7,9],"normal":{"x":-0.6658887345533389,"y":-0.7459030603708008,"z":-0.014863369955244399}},{"index_array":[2,6],"face_index_array":[3,2],"normal":{"x":0.41154230018133986,"y":-0.5040047216553201,"z":-0.7593499046899231}},{"index_array":[6,10],"face_index_array":[9,6],"normal":{"x":0,"y":-0.895404332278156,"z":0.44525423338078374}},{"index_array":[3,7],"face_index_array":[4,3],"normal":{"x":-0.30901727413875957,"y":0.2938927480941581,"z":-0.9045088725045844}},{"index_array":[4,5],"face_index_array":[1,6],"normal":{"x":0.8090172832402858,"y":-0.18163575190584186,"z":0.5590173634030582}},{"index_array":[6,7],"face_index_array":[3,7],"normal":{"x":-0.41154195888934114,"y":-0.5040046410130604,"z":-0.7593501528812778}},{"index_array":[4,10],"face_index_array":[6,5],"normal":{"x":0.30901727413875957,"y":-0.2938927480941581,"z":0.9045088725045844}},{"index_array":[5,6],"face_index_array":[2,6],"normal":{"x":0.6658889624223508,"y":-0.7459029497479648,"z":-0.014863710417325593}}]},"sides":10},
    "d12":{"remap":[7, 5, 6, 2, 4, 1, 3, 0, 8, 9, 10, 11],"geometry":{"vertex_array":[{"x":0.5149316666666667,"y":-0.21291190129222534,"z":-0.6964034498481121},{"x":0,"y":-0.5863091326721404,"z":-0.6723582874671794},{"x":-0.5149316666666667,"y":-0.21291190129222534,"z":-0.6964034498481121},{"x":-0.31840166666666664,"y":0.3912263023215757,"z":-0.7357896607157726},{"x":0.31840166666666664,"y":0.3912263023215757,"z":-0.7357896607157726},{"x":0,"y":0.5863091326721404,"z":0.6723582874671794},{"x":0.5149316666666667,"y":0.21291190129222534,"z":0.6964034498481121},{"x":0.8333333333333334,"y":0.2811319851456038,"z":0.14948052804363227},{"x":0.5149316666666667,"y":-0.6964034498481121,"z":0.21291190129222534},{"x":0.8333333333333334,"y":-0.2811319851456038,"z":-0.14948052804363227},{"x":0.31840166666666664,"y":-0.3912263023215757,"z":0.7357896607157726},{"x":0,"y":0.8852701887594048,"z":0.1100943171759719},{"x":-0.5149316666666667,"y":0.6964034498481121,"z":-0.21291190129222534},{"x":-0.8333333333333334,"y":-0.2811319851456038,"z":-0.14948052804363227},{"x":-0.8333333333333334,"y":0.2811319851456038,"z":0.14948052804363227},{"x":0,"y":-0.8852701887594048,"z":-0.1100943171759719},{"x":-0.31840166666666664,"y":-0.3912263023215757,"z":0.7357896607157726},{"x":-0.5149316666666667,"y":0.21291190129222534,"z":0.6964034498481121},{"x":-0.5149316666666667,"y":-0.6964034498481121,"z":0.21291190129222534},{"x":0.5149316666666667,"y":0.6964034498481121,"z":-0.21291190129222534}],"face_array":[{"index_array":[0,1,2,3,4],"normal":{"x":0,"y":-0.06505556701552073,"z":-0.9978822591970904}},{"index_array":[8,9,7,6,10],"normal":{"x":0.850536,"y":-0.24690307588566732,"z":0.4643571491935883}},{"index_array":[14,12,3,2,13],"normal":{"x":-0.850536,"y":0.24690307588566732,"z":-0.4643571491935883}},{"index_array":[15,8,10,16,18],"normal":{"x":0.000466775,"y":-0.8635836852808229,"z":0.5042054831740654}},{"index_array":[16,10,6,5,17],"normal":{"x":0,"y":0.06505556701552073,"z":0.9978822591970904}},{"index_array":[13,18,16,17,14],"normal":{"x":-0.850535,"y":-0.2469035453572301,"z":0.46435803214118115}},{"index_array":[15,18,13,2,1],"normal":{"x":-0.525789,"y":-0.7512674972488992,"z":-0.39892761682851496}},{"index_array":[11,12,14,17,5],"normal":{"x":-0.525918,"y":0.7509787138398603,"z":0.3993024651256604}},{"index_array":[11,5,6,7,19],"normal":{"x":0.52566,"y":0.7511191025071249,"z":0.39937711110414337}},{"index_array":[11,19,4,3,12],"normal":{"x":0.000465599,"y":0.8635836852808229,"z":-0.5042054831740654}},{"index_array":[19,7,9,0,4],"normal":{"x":0.850535,"y":0.2469035453572301,"z":-0.46435803214118115}},{"index_array":[8,15,1,0,9],"normal":{"x":0.525918,"y":-0.7509787138398603,"z":-0.3993024651256604}}],"edge_array":[{"index_array":[0,1],"face_index_array":[0,11],"normal":{"x":0.309177,"y":-0.4792657543670661,"z":-0.8214096154270214}},{"index_array":[16,18],"face_index_array":[3,5],"normal":{"x":-0.500136,"y":-0.6527825097212672,"z":0.5689796076969751}},{"index_array":[16,17],"face_index_array":[5,4],"normal":{"x":-0.500061,"y":-0.10664624199092015,"z":0.8593982567530691}},{"index_array":[0,4],"face_index_array":[10,0],"normal":{"x":0.499938,"y":0.10660120313731386,"z":-0.8594754351287053}},{"index_array":[15,18],"face_index_array":[6,3],"normal":{"x":-0.309253,"y":-0.9489651959002473,"z":0.06186644246281975}},{"index_array":[0,9],"face_index_array":[11,10],"normal":{"x":0.808719,"y":-0.29678565259019934,"z":-0.507830167679717}},{"index_array":[1,2],"face_index_array":[0,6],"normal":{"x":-0.309055,"y":-0.47910616445213994,"z":-0.8215478762640429}},{"index_array":[14,17],"face_index_array":[7,5],"normal":{"x":-0.808871,"y":0.2963201018629518,"z":0.5078601096295414}},{"index_array":[1,15],"face_index_array":[6,11],"normal":{"x":0.000151461,"y":-0.882947592858927,"z":-0.4694715627858908}},{"index_array":[13,18],"face_index_array":[5,6],"normal":{"x":-0.808842,"y":-0.5867807189274731,"z":0.0382549758849475}},{"index_array":[2,3],"face_index_array":[0,2],"normal":{"x":-0.499939,"y":0.10660073366575107,"z":-0.8594745521811124}},{"index_array":[2,13],"face_index_array":[2,6],"normal":{"x":-0.808842,"y":-0.2964092710434601,"z":-0.5078542909314488}},{"index_array":[3,4],"face_index_array":[0,9],"normal":{"x":0,"y":0.4693378306605288,"z":-0.8830186994912981}},{"index_array":[13,14],"face_index_array":[2,5],"normal":{"x":-1,"y":0,"z":0}},{"index_array":[3,12],"face_index_array":[9,2],"normal":{"x":-0.50026,"y":0.652693340540759,"z":-0.5689737889988825}},{"index_array":[12,14],"face_index_array":[7,2],"normal":{"x":-0.808918,"y":0.5866627013631841,"z":-0.038454767913115084}},{"index_array":[11,19],"face_index_array":[9,8],"normal":{"x":0.309253,"y":0.9489651959002473,"z":-0.06186644246281975}},{"index_array":[4,19],"face_index_array":[10,9],"normal":{"x":0.500259,"y":0.6526938100123217,"z":-0.5689746719464753}},{"index_array":[11,12],"face_index_array":[7,9],"normal":{"x":-0.309253,"y":0.9489651959002473,"z":-0.06186644246281975}},{"index_array":[5,6],"face_index_array":[8,4],"normal":{"x":0.309055,"y":0.47910616445213994,"z":0.8215478762640429}},{"index_array":[10,16],"face_index_array":[3,4],"normal":{"x":0,"y":-0.46933786156369456,"z":0.8830186830597934}},{"index_array":[5,17],"face_index_array":[4,7],"normal":{"x":-0.309177,"y":0.4792657543670661,"z":0.8214096154270214}},{"index_array":[5,11],"face_index_array":[7,8],"normal":{"x":-0.000151461,"y":0.882947592858927,"z":0.4694715627858908}},{"index_array":[6,7],"face_index_array":[8,1],"normal":{"x":0.808842,"y":0.2964092710434601,"z":0.5078542909314488}},{"index_array":[6,10],"face_index_array":[1,4],"normal":{"x":0.499939,"y":-0.10660073366575107,"z":0.8594745521811124}},{"index_array":[8,15],"face_index_array":[11,3],"normal":{"x":0.309376,"y":-0.9489388750763101,"z":0.06165505605306898}},{"index_array":[7,9],"face_index_array":[10,1],"normal":{"x":1,"y":0,"z":0}},{"index_array":[8,10],"face_index_array":[3,1],"normal":{"x":0.50026,"y":-0.652693340540759,"z":0.5689737889988825}},{"index_array":[8,9],"face_index_array":[1,11],"normal":{"x":0.808795,"y":-0.5868522892234673,"z":0.0381297133896375}},{"index_array":[7,19],"face_index_array":[8,10],"normal":{"x":0.808918,"y":0.586663170834747,"z":-0.0384556508607079}}]},"sides":12},
    "d20":{"remap":[2, 1, 0, 4, 3, 7, 6, 5, 9, 8, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19], "geometry":{"vertex_array":[{"x":0,"y":-0.9659258262890683,"z":0.25881904510252074},{"x":0.8506506267003252,"y":-0.5035113618811431,"z":-0.15122777481646782},{"x":0.5257309789904098,"y":-0.24469226870440436,"z":0.8146982308880245},{"x":-0.5257313391170517,"y":-0.2446923434771421,"z":0.8146979518323682},{"x":-0.8506509660565227,"y":-0.5035113333830682,"z":-0.1512276684602043},{"x":0,"y":-0.6634703749649558,"z":-0.7482029387738315},{"x":0.5257313391170517,"y":0.2446923434771421,"z":-0.8146979518323682},{"x":0.8506509660565227,"y":0.5035113333830682,"z":0.1512276684602043},{"x":0,"y":0.6634703749649558,"z":0.7482029387738315},{"x":-0.8506506267003252,"y":0.5035113618811431,"z":0.15122777481646782},{"x":-0.5257309789904098,"y":0.24469226870440436,"z":-0.8146982308880245},{"x":0,"y":0.9659258262890683,"z":-0.25881904510252074}],"face_array":[{"index_array":[0,1,2],"normal":{"x":0.5773497914192821,"y":-0.7190243008052122,"z":0.3868720637739136}},{"index_array":[0,2,3],"normal":{"x":0,"y":-0.6104576390690677,"z":0.7920483613813487}},{"index_array":[0,3,4],"normal":{"x":-0.5773502708951684,"y":-0.7190243164093653,"z":0.38687200553842166}},{"index_array":[0,4,5],"normal":{"x":-0.3568215557072163,"y":-0.8946889015776134,"z":-0.26871715139999075}},{"index_array":[0,5,1],"normal":{"x":0.3568216674855672,"y":-0.8946888699788245,"z":-0.26871703347170495}},{"index_array":[1,6,7],"normal":{"x":0.9341724099613656,"y":0.10264034996952541,"z":-0.34174082942795614}},{"index_array":[2,7,8],"normal":{"x":0.5773501591168175,"y":0.3868715808792821,"z":0.7190245654250975}},{"index_array":[3,8,9],"normal":{"x":-0.577349903197633,"y":0.3868715652751291,"z":0.7190245071896055}},{"index_array":[4,9,10],"normal":{"x":-0.9341718266023848,"y":0.10264038274606682,"z":-0.3417407071042382}},{"index_array":[5,10,6],"normal":{"x":0,"y":-0.07302320489756609,"z":-0.99733000493341}},{"index_array":[7,2,1],"normal":{"x":0.9341718266023848,"y":-0.10264134867189315,"z":0.3417409659232833}},{"index_array":[8,3,2],"normal":{"x":0,"y":0.07302320489756609,"z":0.99733000493341}},{"index_array":[9,4,3],"normal":{"x":-0.9341724099613656,"y":-0.10264034996952541,"z":0.34174082942795614}},{"index_array":[10,5,4],"normal":{"x":-0.5773501591168175,"y":-0.3868715808792821,"z":-0.7190245654250975}},{"index_array":[6,1,5],"normal":{"x":0.577349903197633,"y":-0.3868715652751291,"z":-0.7190245071896055}},{"index_array":[11,8,7],"normal":{"x":0.3568215557072163,"y":0.8946889015776134,"z":0.26871715139999075}},{"index_array":[11,9,8],"normal":{"x":-0.3568226185420835,"y":0.8946889499583078,"z":0.26871733195920056}},{"index_array":[11,10,9],"normal":{"x":-0.5773497914192821,"y":0.7190252667310385,"z":-0.3868723225929587}},{"index_array":[11,6,10],"normal":{"x":0,"y":0.6104576390690677,"z":-0.7920483613813487}},{"index_array":[11,7,6],"normal":{"x":0.5773502708951684,"y":0.7190252823351916,"z":-0.3868722643574668}}],"edge_array":[{"index_array":[0,1],"face_index_array":[0,4],"normal":{"x":0.4999998933683673,"y":-0.8637134638483929,"z":0.06324054997098227}},{"index_array":[0,2],"face_index_array":[1,0],"normal":{"x":0.3090171388247843,"y":-0.7115834672395087,"z":0.6309974266706189}},{"index_array":[0,3],"face_index_array":[2,1],"normal":{"x":-0.30901660824247307,"y":-0.711583486033115,"z":0.6309973565319251}},{"index_array":[0,4],"face_index_array":[3,2],"normal":{"x":-0.4999996173439993,"y":-0.8637135065260279,"z":0.06324039069588}},{"index_array":[0,5],"face_index_array":[4,3],"normal":{"x":0,"y":-0.9577350066255503,"z":-0.28765262467938}},{"index_array":[1,2],"face_index_array":[0,10],"normal":{"x":0.8090170321931517,"y":-0.43978254155143515,"z":0.3899778129713857}},{"index_array":[1,5],"face_index_array":[14,4],"normal":{"x":0.5000000378182042,"y":-0.6859340809374768,"z":-0.5286722383786132}},{"index_array":[1,6],"face_index_array":[5,14],"normal":{"x":0.8090174526673567,"y":-0.15213005779476121,"z":-0.5677571050484386}},{"index_array":[1,7],"face_index_array":[10,5],"normal":{"x":1.000000461768883,"y":0,"z":0}},{"index_array":[2,3],"face_index_array":[1,11],"normal":{"x":0,"y":-0.28765248375667396,"z":0.9577349180198242}},{"index_array":[2,7],"face_index_array":[6,10],"normal":{"x":0.8090167561687835,"y":0.15213003928651914,"z":0.5677570359747389}},{"index_array":[2,8],"face_index_array":[11,6],"normal":{"x":0.3090169943749474,"y":0.2461515393860416,"z":0.9186500513499989}},{"index_array":[3,4],"face_index_array":[2,12],"normal":{"x":-0.8090171766429887,"y":-0.4397825230431931,"z":0.3899778820450854}},{"index_array":[3,8],"face_index_array":[7,11],"normal":{"x":-0.30901675269230994,"y":0.24615152059243528,"z":0.9186499812113053}},{"index_array":[3,9],"face_index_array":[12,7],"normal":{"x":-0.8090174526673567,"y":0.15213005779476121,"z":0.5677571050484386}},{"index_array":[4,5],"face_index_array":[3,13],"normal":{"x":-0.49999947289416236,"y":-0.6859341236151117,"z":-0.5286723976537155}},{"index_array":[4,9],"face_index_array":[8,12],"normal":{"x":-1,"y":0,"z":0}},{"index_array":[4,10],"face_index_array":[13,8],"normal":{"x":-0.8090167561687835,"y":-0.15213003928651914,"z":-0.5677570359747389}},{"index_array":[5,10],"face_index_array":[9,13],"normal":{"x":-0.3090169943749474,"y":-0.2461515393860416,"z":-0.9186500513499989}},{"index_array":[5,6],"face_index_array":[14,9],"normal":{"x":0.30901675269230994,"y":-0.24615152059243528,"z":-0.9186499812113053}},{"index_array":[6,7],"face_index_array":[5,19],"normal":{"x":0.8090171766429887,"y":0.4397825230431931,"z":-0.3899778820450854}},{"index_array":[6,10],"face_index_array":[18,9],"normal":{"x":0,"y":0.28765248375667396,"z":-0.9577349180198242}},{"index_array":[6,11],"face_index_array":[19,18],"normal":{"x":0.30901660824247307,"y":0.711583486033115,"z":-0.6309973565319251}},{"index_array":[7,8],"face_index_array":[6,15],"normal":{"x":0.5000004239506787,"y":0.6859340436356284,"z":0.5286720991662199}},{"index_array":[7,11],"face_index_array":[15,19],"normal":{"x":0.4999996173439993,"y":0.8637135065260279,"z":-0.06324039069588}},{"index_array":[8,9],"face_index_array":[7,16],"normal":{"x":-0.5000000378182042,"y":0.6859340809374768,"z":0.5286722383786132}},{"index_array":[8,11],"face_index_array":[16,15],"normal":{"x":0,"y":0.9577350066255503,"z":0.28765262467938}},{"index_array":[9,10],"face_index_array":[8,17],"normal":{"x":-0.8090170321931517,"y":0.43978254155143515,"z":-0.3899778129713857}},{"index_array":[9,11],"face_index_array":[17,16],"normal":{"x":-0.4999998933683673,"y":0.8637134638483929,"z":-0.06324054997098227}},{"index_array":[10,11],"face_index_array":[18,17],"normal":{"x":-0.3090171388247843,"y":0.7115834672395087,"z":-0.6309974266706189}}]},"sides":20}}

// Create inverse table
for die at name in _dice_DATA_TABLE:
    die.unmap = []
    for i at j in die.remap:
        die.unmap[i] = j
        
